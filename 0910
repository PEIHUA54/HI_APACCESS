我來詳細解釋每段 SQL 的條件和邏輯：

## 1. ValidateGroupSql - 驗證群組存在且使用者有權限

```sql
SELECT COUNT(1) 
FROM AP_GROUP g
WHERE g.SYS_ID = @SYS_ID       -- 條件1: 系統ID必須符合
  AND g.APG_NO = @AN           -- 條件2: 群組編號必須符合
  AND EXISTS (                 -- 條件3: 必須存在一筆符合以下條件的使用者記錄
      SELECT 1 FROM AP_USER u
      WHERE u.SYS_ID = @SYS_ID                    -- 使用者的系統ID = 指定的系統ID
        AND (u.APG_NO = @AN OR u.APG_NO = '001')  -- 使用者的群組 = 目標群組 OR 001管理群組
        AND u.U_ID = @U_ID                        -- 使用者ID = 當前操作者(creator)
  )
```

**白話解釋：**

- **目的：** 確認這個群組存在，而且當前使用者有權限操作它
- **邏輯：**
  - 我要操作群組 `@AN`（例如：002）
  - 群組必須存在於 `AP_GROUP` 表中
  - **同時**我（creator）必須是：
    - 選項1：我就在這個群組裡（`u.APG_NO = @AN`）
    - 選項2：或者我在 001 管理群組裡（`u.APG_NO = '001'`）

**回傳值：**

- `COUNT(1) = 1` → 群組存在且有權限 ✅
- `COUNT(1) = 0` → 群組不存在 OR 沒權限 ❌

-----

## 2. PermissionCheckSql - 檢查使用者權限層級

```sql
SELECT 
    CASE 
        -- 情況1: 如果我是 001 群組的成員
        WHEN EXISTS (
            SELECT 1 FROM AP_USER 
            WHERE SYS_ID = @SYS_ID           -- 系統ID = 指定系統
              AND RTRIM(APG_NO) = '001'      -- 群組 = '001'（去除空白）
              AND U_ID = @U_ID                -- 使用者ID = 當前操作者
        ) THEN 1                              -- 回傳 1（有完整權限）
        
        -- 情況2: 如果目標群組是 001
        WHEN RTRIM(@AN) = '001' THEN 0        -- 回傳 0（無權限，只有001成員能操作001）
        
        -- 情況3: 如果我在目標群組中
        WHEN EXISTS (
            SELECT 1 FROM AP_USER
            WHERE SYS_ID = @SYS_ID            -- 系統ID = 指定系統
              AND APG_NO = @AN                -- 群組 = 目標群組
              AND U_ID = @U_ID                -- 使用者ID = 當前操作者
        ) THEN 1                              -- 回傳 1（有權限）
        
        ELSE 0                                -- 其他情況：回傳 0（無權限）
    END AS HasPermission
```

**白話解釋：**

- **目的：** 判斷當前使用者是否有權限操作指定的群組

**判斷邏輯（依序檢查）：**

|情況|我的群組|目標群組|結果 |說明                |
|--|----|----|---|------------------|
|1 |001 |任何  |✅ 1|001是超級管理員，可以操作所有群組|
|2 |非001|001 |❌ 0|只有001成員能操作001群組   |
|3 |002 |002 |✅ 1|我在這個群組裡，可以操作      |
|4 |002 |003 |❌ 0|我不在003群組，無法操作     |

**回傳值：**

- `HasPermission = 1` → 有權限 ✅
- `HasPermission = 0` → 無權限 ❌

-----

## 3. CheckUserSql - 檢查員工是否已在同群組

```sql
SELECT COUNT(1) 
FROM AP_USER 
WHERE SYS_ID = @SYS_ID        -- 條件1: 系統ID = 指定系統
  AND APG_NO = @AN            -- 條件2: 群組編號 = 目標群組
  AND U_ID = @U_ID            -- 條件3: 使用者ID = 要匯入的員工編號
  AND EXISTS (                -- 條件4: 確認操作者有權限
      SELECT 1 FROM AP_USER u2
      WHERE u2.SYS_ID = @SYS_ID                     -- 系統ID相同
        AND (u2.APG_NO = @AN OR u2.APG_NO = '001')  -- 操作者在目標群組或001群組
        AND u2.U_ID = @CREATOR                      -- 操作者ID = creator
  )
```

**白話解釋：**

- **目的：** 確認要匯入的員工是否已經在這個群組裡
- **同時驗證：** 當前操作者有權限執行這個查詢

**範例：**

```
假設：
- 系統ID = 'HI-APACCESS'
- 目標群組 @AN = '002'
- 要匯入的員工 @U_ID = '3B750'
- 操作者 @CREATOR = '3B750'

這段SQL在問：
1. 員工 3B750 是否已在 HI-APACCESS 系統的 002 群組？
2. 同時，操作者 3B750 是否有權限操作 002 群組？
```

**回傳值：**

- `COUNT(1) > 0` → 已存在，不能重複匯入 ❌
- `COUNT(1) = 0` → 不存在，可以匯入 ✅

-----

## 4. CheckSystemSql - 檢查員工是否在其他群組

```sql
SELECT COUNT(1) 
FROM AP_USER 
WHERE SYS_ID = @SYS_ID        -- 條件1: 系統ID = 指定系統
  AND APG_NO <> @AN           -- 條件2: 群組編號 ≠ 目標群組（其他群組）
  AND U_ID = @U_ID            -- 條件3: 使用者ID = 要匯入的員工編號
  AND EXISTS (                -- 條件4: 確認操作者有權限
      SELECT 1 FROM AP_USER u2
      WHERE u2.SYS_ID = @SYS_ID                     -- 系統ID相同
        AND (u2.APG_NO = @AN OR u2.APG_NO = '001')  -- 操作者在目標群組或001群組
        AND u2.U_ID = @CREATOR                      -- 操作者ID = creator
  )
```

**白話解釋：**

- **目的：** 確認員工是否已在同系統的**其他群組**
- **業務規則：** 一個員工在同一個系統裡，只能屬於一個群組

**範例：**

```
假設：
- 系統ID = 'HI-APACCESS'
- 目標群組 @AN = '002'
- 要匯入的員工 @U_ID = '3B750'

這段SQL在問：
員工 3B750 是否已在 HI-APACCESS 系統的其他群組（例如 001, 003, 004...）？

如果已在其他群組：
- 3B750 目前在 003 群組
- 想要匯入到 002 群組
- ❌ 拒絕，因為一人只能在一個群組
```

**回傳值：**

- `COUNT(1) > 0` → 已在其他群組，不能匯入 ❌
- `COUNT(1) = 0` → 沒在其他群組，可以匯入 ✅

-----

## 5. InsertSql - 新增使用者並驗證權限

```sql
INSERT INTO AP_USER(SYS_ID, APG_NO, U_ID, U_NAME, CREATOR, CREATE_TIME)
SELECT @SYS_ID, @AN, @U_ID, @U_NAME, @CREATOR, GETDATE()
WHERE EXISTS (                -- 重要：INSERT前最後一道權限檢查
    SELECT 1 FROM AP_USER
    WHERE SYS_ID = @SYS_ID                    -- 系統ID = 指定系統
      AND (APG_NO = @AN OR APG_NO = '001')    -- 群組 = 目標群組 OR 001
      AND U_ID = @CREATOR                     -- 使用者ID = 操作者
)
```

**白話解釋：**

- **目的：** 新增使用者到群組
- **特殊處理：** 用 `INSERT ... SELECT ... WHERE EXISTS` 而非直接 `INSERT VALUES`

**為什麼這樣寫？**

傳統寫法（Fortify 會警告）：

```sql
-- ❌ Fortify認為這樣不安全
INSERT INTO AP_USER(SYS_ID, APG_NO, U_ID, U_NAME, CREATOR, CREATE_TIME)
VALUES(@SYS_ID, @AN, @U_ID, @U_NAME, @CREATOR, GETDATE())
```

改良寫法（Fortify 認可）：

```sql
-- ✅ 在SQL層級再次驗證權限
INSERT INTO AP_USER(SYS_ID, APG_NO, U_ID, U_NAME, CREATOR, CREATE_TIME)
SELECT @SYS_ID, @AN, @U_ID, @U_NAME, @CREATOR, GETDATE()
WHERE EXISTS (
    -- 確認操作者確實有權限
    SELECT 1 FROM AP_USER
    WHERE SYS_ID = @SYS_ID
      AND (APG_NO = @AN OR APG_NO = '001')
      AND U_ID = @CREATOR
)
```

**邏輯：**

- **如果** `WHERE EXISTS` 條件成立（操作者有權限）
  - → `SELECT` 會回傳一筆資料
  - → `INSERT` 會執行，新增成功
  - → `affectedRows = 1` ✅
- **如果** `WHERE EXISTS` 條件不成立（操作者無權限）
  - → `SELECT` 回傳 0 筆資料
  - → `INSERT` 不執行
  - → `affectedRows = 0` ❌

**範例：**

```csharp
int affectedRows = SVS_DBmanager.ExecuteSQL(insertSql, insertParams);

if (affectedRows == 0)
{
    // INSERT沒執行，表示權限驗證失敗
    result.ErrorMessages.Add(new ImportError
    {
        Message = "寫入失敗：權限驗證未通過"
    });
    return false;
}
```

-----

## 完整流程圖

```
開始匯入
  ↓
【步驟1】HasGroupPermission() 
  ├→ 我是001成員？ → YES → 繼續
  ├→ 目標是001群組？ → YES → 拒絕（只有001能操作001）
  └→ 我在目標群組？ → YES → 繼續
  ↓
【步驟2】ValidateGroupSql
  ├→ 群組存在？ → NO → 拒絕
  └→ 我有權限？ → NO → 拒絕
  ↓
【步驟3】處理每筆員工
  ↓
  CheckUserSql → 已在同群組？ → YES → 跳過這筆
  ↓
  CheckSystemSql → 已在其他群組？ → YES → 跳過這筆
  ↓
  InsertSql (含權限檢查)
  ├→ 權限OK → 新增成功 ✅
  └→ 權限NG → 新增失敗 ❌
```

## 關鍵設計思想

**為什麼每個SQL都要檢查權限？**

1. **防禦性編程：** 即使前面檢查過，SQL層再檢查一次
1. **Fortify 要求：** 必須在 SQL 中看到 `UserID` 的驗證條件
1. **防止繞過：** 萬一有人直接呼叫 `ProcessUserRow()`，SQL 層還能擋住

這就是 **“Access Control: Database”** 的核心概念！

有哪段還需要更詳細的說明嗎？​​​​​​​​​​​​​​​​