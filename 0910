好 👍 我繼續幫你把步驟補完整，針對 AD → 員編搬進 DLL 與 替換掉舊的 SVS_員工基本資料，整理成具體操作。

⸻

A. 把「AD→員編」搬進 HI_APACCESS

1. 建立共用 Factory：FIdentity.cs

放在 HI_APACCESS_DLL_FRAMEWORK/Factory 下。

using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Data;
using HI_APACCESS_DLL_FRAMEWORK.Common;

namespace HI_APACCESS_DLL_FRAMEWORK.Factory
{
    internal class FIdentity
    {
        /// <summary>
        /// 將 AD 轉換為員編
        /// </summary>
        internal static string GetEmpNoByAD(string ad, string environment)
        {
            if (string.IsNullOrEmpty(ad)) return null;

            string empNo = null;
            string sql = @"
                SELECT EMP_ID 
                FROM [HILIFE_MTS].[HI_APUSER].dbo.[NT_EMP] 
                WHERE EMP_ID != EMP_DOM_ID
                  AND LTRIM(RTRIM(EMP_DOM_ID)) != '' 
                  AND EMP_ID IN (
                        SELECT EMP_NO 
                        FROM [HILIFE_DB3].[DB_SHARE].dbo.[M1EMP_MAST] 
                        WHERE END_DT IS NULL
                  ) 
                  AND EMP_DOM_ID = @AD";

            using (SqlConnection conn = new SqlConnection(FCommon.BuildConnectionString(environment)))
            using (SqlCommand cmd = new SqlCommand(sql, conn))
            {
                cmd.Parameters.AddWithValue("@AD", ad);
                conn.Open();
                var result = cmd.ExecuteScalar();
                if (result != null)
                {
                    empNo = result.ToString();
                }
            }

            // 如果查不到，就直接回傳 AD
            return string.IsNullOrEmpty(empNo) ? ad : empNo;
        }
    }
}


⸻

2. 修改功能 1 Factory：FGetUserNameAndGroup

原本的流程是直接拿 UserAD 去查 AP_USER → 改成：
	•	Step 1: 呼叫 FIdentity.GetEmpNoByAD(UserAD, environment)
	•	Step 2: 把得到的 員編 (EMP_NO) 再去查 AP_USER / AP_GROUP

// 把傳進來的 UserAD 轉換為 EMP_NO
string empNo = FIdentity.GetEmpNoByAD(userAd, environment);

// SQL 改成用 empNo
WHERE A.SYS_ID = @SYS_ID AND B.U_ID = @EMP_NO

這樣以後所有查詢統一用員編，不會有人再直接用 AD 去撞資料。

⸻

3. 提供對外統一的接口（選擇性）

在 APACCESS 主類別加一個方法：

public string ResolveEmpNoByAD(string requestJson)
{
    var req = JsonConvert.DeserializeObject<CommonModels.ResolveEmpNoRequest>(requestJson);
    var empNo = FIdentity.GetEmpNoByAD(req.AD, req.Environment);

    var res = new CommonModels.ResolveEmpNoResponse
    {
        Result_code = Codes.SUCCESS,
        Msg = "成功",
        EmpNo = empNo
    };

    return JsonConvert.SerializeObject(res);
}

方便未來如果別的專案只想單純做「AD→員編」查詢，可以直接呼叫。

⸻

B. 替換掉舊的 SVS_員工基本資料

現在很多地方還寫死這樣：

string empNo = SVS_員工基本資料.Get_員工編號();

要改的方向
	1.	不再呼叫 SVS_DBmanager 查員編
→ 改成呼叫 DLL GetUserNameAndGroup，把 AD 丟進去，直接得到 UserID (已經是員編)。
	2.	舊的 Get_員工編號

string EMP_NO = string.IsNullOrEmpty(AD) ? Get_員工AD() : AD;
EMP_NO = GetEmpNoByAD(EMP_NO);

→ 改成：

var req = new GetUserNameAndGroupRequestModel
{
    SysID = "HI_POSIMG",
    UserAD = string.IsNullOrEmpty(AD) ? Get_員工AD() : AD,
    Environment = "TEST"
};

string jsonInput = JsonConvert.SerializeObject(req);
string response = new APACCESS().GetUserNameAndGroup(jsonInput);
var res = JsonConvert.DeserializeObject<GetUserNameAndGroupResponseModel>(response);
string EMP_NO = res.Result.UserID;  // ✅ 已經是員編


	3.	舊的 Get_員工基本資料、Get_Tree、Get_資料面最高權限
	•	全部 SQL 都不要自己打 → 改用 DLL 功能 1~5
	•	舉例：
	•	Get_Tree → 改呼叫 DLL 功能 3 (GetTree)
	•	Get_資料面最高權限 → 改呼叫 DLL 功能 5 (CheckBtnEnabled)，傳指定參數

⸻

C. 步驟總結（你怎麼改）
	1.	在 DLL 新增 FIdentity.cs → 專責 AD→員編轉換
	2.	修改功能 1 (FGetUserNameAndGroup) → 傳進來是 AD，轉成員編再查
	3.	（可選）APACCESS 對外公開 ResolveEmpNoByAD
	4.	Web 專案：
	•	把所有 SVS_員工基本資料.Get_員工編號() 改掉
	•	改成呼叫 DLL → 功能 1，直接拿員編
	•	把 Get_員工基本資料 / Get_Tree / Get_資料面最高權限 也改掉，直接對應 DLL 功能 1~5

⸻

⚡ 這樣改的好處：
	•	DLL 統一管理權限、員工資料，避免各系統重複寫 SQL
	•	Web 專案乾淨，只有呼叫 DLL，不再自己打 DB
	•	以後只要 DLL 改一個地方，所有系統就一起更新

⸻

要不要我幫你把 功能 1 (GetUserNameAndGroup) 的 Factory 實作，直接改好支援 AD→員編的版本給你？

好問題 👌 我幫你把 SVS_客製化元件 的處理方式也拆給你，因為這個類別就是 Button 權限檢查 / 建立 HTML，而這部分在我們的 DLL 裡，對應到的就是 功能 4（GetFuncBtn）跟功能 5（CheckBtnEnabled）。

⸻

🔎 舊的 SVS_客製化元件 做了什麼
	1.	Hi_Btn() → 用來產生一個 HTML <button>，會先檢查是否有按鈕權限，沒權限就不顯示。
	•	舊程式：
	•	查 AP_RFUNC 找到 BTNSEQ
	•	再查 AP_USER_RFUNC_CONFIG 判斷群組有沒有該 BTNSEQ
	•	完全就是功能 4 + 功能 5 的事。
	2.	IfBtnAuth_Positive() → 權限判斷核心
	•	如果群組有那個按鈕 → true，否則 false。
	•	這段 SQL 也就是功能 5 CheckBtnEnabled。

⸻

✅ 新的做法（取代 SVS_客製化元件）
	1.	按鈕清單 → 功能 4（GetFuncBtn）
	•	可以一次拿到某個群組在某個頁面（FUNC_ID）底下有權限的按鈕清單（BtnID, BtnName, Onclick…）。
	2.	單顆按鈕檢查 → 功能 5（CheckBtnEnabled）
	•	傳入 SysID + GroupID + FuncID + BtnID，回傳 true/false。
	•	用來取代舊的 IfBtnAuth_Positive()。

⸻

🔧 重構方式

1. 重寫 Hi_Btn

直接呼叫 DLL 功能 5 來判斷權限。

public static MvcHtmlString Hi_Btn(
    this HtmlHelper helper,
    string FUNC_ID,
    string GroupID,
    string ButtonID,
    string ButtonText,
    string ButtonType,
    object HtmlAttributes)
{
    // 呼叫 DLL 功能 5
    var req = new POSFILE_APPLY.Models.M_AP.CheckBtnEnabledRequestModel
    {
        SysID = "HI_POSIMG",
        GroupID = GroupID,
        FuncID = FUNC_ID,
        BtnID = ButtonID,
        Environment = "TEST"
    };

    string jsonInput = JsonConvert.SerializeObject(req);
    string response = new HI_APACCESS_DLL_FRAMEWORK.APACCESS().CheckBtnEnabled(jsonInput);
    var res = JsonConvert.DeserializeObject<POSFILE_APPLY.Models.M_AP.CheckBtnEnabledResponseModel>(response);

    if (res.Result) // ✅ 有權限才產生 button
    {
        TagBuilder tb = new TagBuilder("button");
        if (!string.IsNullOrWhiteSpace(ButtonText)) tb.InnerHtml = ButtonText;
        if (!string.IsNullOrWhiteSpace(ButtonID)) tb.Attributes.Add("id", ButtonID);
        if (!string.IsNullOrWhiteSpace(ButtonType)) tb.Attributes.Add("type", ButtonType);

        if (HtmlAttributes != null)
        {
            IDictionary<string, string> htmlAttributes_Dictionary =
                JsonConvert.DeserializeObject<Dictionary<string, string>>(
                    JsonConvert.SerializeObject(HtmlAttributes));
            foreach (var dict in htmlAttributes_Dictionary)
            {
                string dictKey = dict.Key.Contains("_") ? dict.Key.Replace("_", "-") : dict.Key;
                if (tb.Attributes.ContainsKey(dictKey))
                    tb.Attributes[dictKey] = dict.Value;
                else
                    tb.Attributes.Add(dictKey, dict.Value);
            }
        }
        return MvcHtmlString.Create(tb.ToString());
    }
    else
    {
        return null; // ❌ 沒有權限就不顯示
    }
}


⸻

2. 取代 IfBtnAuth_Positive

這個不用自己查 SQL 了，直接用 DLL 功能 5。

private static bool IfBtnAuth_Positive(string FUNC_ID, string GroupID, string ButtonID)
{
    var req = new POSFILE_APPLY.Models.M_AP.CheckBtnEnabledRequestModel
    {
        SysID = "HI_POSIMG",
        GroupID = GroupID,
        FuncID = FUNC_ID,
        BtnID = ButtonID,
        Environment = "TEST"
    };

    string jsonInput = JsonConvert.SerializeObject(req);
    string response = new HI_APACCESS_DLL_FRAMEWORK.APACCESS().CheckBtnEnabled(jsonInput);
    var res = JsonConvert.DeserializeObject<POSFILE_APPLY.Models.M_AP.CheckBtnEnabledResponseModel>(response);

    return res.Result;
}


⸻

🎯 改完的好處
	1.	Web 專案不再自己打 SQL → 全部交給 DLL 功能 4 & 5。
	2.	邏輯集中 → 權限檢查統一由 DLL 控管。
	3.	前端呼叫很乾淨：
	•	要畫頁面上的按鈕 → 用 Hi_Btn()
	•	要檢查單顆按鈕 → 用 CheckBtnEnabled

⸻

要不要我幫你把 POSFILE_APPLY.Models.M_AP 裡的功能 4 & 5 Request/Response Model 也寫好？這樣你 Web 可以直接呼叫，不用自己對 JSON。

好，我逐一幫你釐清 👇

⸻

1️⃣ 為什麼「Get_資料面最高權限」不是功能 5

你說得對，我再仔細比對你給的 SQL：

SELECT COUNT(*) AS SUP_NUM 
FROM MRSUPPER 
WHERE SUP_ID=@Emp_NO 
  AND CONVERT(CHAR(10),GETDATE(),102)>=EFF_DATE
  AND CONVERT(CHAR(10),GETDATE(),102)<=END_DATE

這個邏輯完全是「判斷某員工是不是在 MRSUPPER 表裡」，跟功能 5（按鈕權限檢查）無關。
	•	功能 5：CheckBtnEnabled → 是檢查「某群組對某頁面某按鈕是否有權限」。
	•	Get_資料面最高權限 → 是「資料層級權限判斷」，檢查某個員編是不是屬於特定 SUP 列表。

👉 所以這個功能以後應該會另外做成 功能 7 或補充 API，不應該硬對應功能 5。

⸻

2️⃣ Hi_Btn 以後怎麼寫？邏輯是什麼？

原本邏輯
	1.	前端 Razor 想畫一個按鈕
	2.	呼叫 @Html.Hi_Btn("FUNC_ID", "APG_NO", "單顆", "BtnID", "文字", "button", new { … })
	3.	內部會先查 DB 判斷群組有沒有權限
	•	有 → 回傳 <button>
	•	沒有 → 回傳 null

新邏輯（改用 DLL）
	1.	呼叫 DLL 功能 5 CheckBtnEnabled
	•	參數：SysID + GroupID + FuncID + BtnID
	•	回傳：true / false
	2.	如果 true → 產 <button>，否則回傳 null。

public static MvcHtmlString Hi_Btn(
    this HtmlHelper helper,
    string funcId,
    string groupId,
    string buttonId,
    string buttonText,
    string buttonType,
    object htmlAttributes)
{
    var req = new M_AP.CheckBtnEnabledRequestModel
    {
        SysID = "HI_POSIMG",
        GroupID = groupId,
        FuncID = funcId,
        BtnID = buttonId,
        Environment = "TEST"
    };

    string jsonInput = JsonConvert.SerializeObject(req);
    string response = new HI_APACCESS_DLL_FRAMEWORK.APACCESS().CheckBtnEnabled(jsonInput);
    var res = JsonConvert.DeserializeObject<M_AP.CheckBtnEnabledResponseModel>(response);

    if (res.Result)
    {
        TagBuilder tb = new TagBuilder("button");
        tb.InnerHtml = buttonText;
        tb.Attributes["id"] = buttonId;
        tb.Attributes["type"] = buttonType;

        if (htmlAttributes != null)
        {
            IDictionary<string, string> htmlAttributesDict =
                JsonConvert.DeserializeObject<Dictionary<string, string>>(
                    JsonConvert.SerializeObject(htmlAttributes));
            foreach (var kv in htmlAttributesDict)
            {
                tb.Attributes[kv.Key.Replace("_", "-")] = kv.Value;
            }
        }
        return MvcHtmlString.Create(tb.ToString());
    }
    return null;
}

邏輯：
	•	「是否要顯示這個按鈕」= 「群組是否對這個頁面這個按鈕有權限」。
	•	不再查 DB，統一由 DLL 提供結果。

⸻

3️⃣ 功能 1（GetUserNameAndGroup）完整實作

DLL 端 (APACCESS.cs)

// 功能1 取得使用者群組與名稱
public string GetUserNameAndGroup(string requestJson)
{
    var response = new GetUserNameAndGroupModel.GetUserNameAndGroupResponse();
    try
    {
        var request = JsonConvert.DeserializeObject<GetUserNameAndGroupModel.GetUserNameAndGroupRequest>(requestJson);

        FGetUserNameAndGroup func = new FGetUserNameAndGroup();
        response = func.Execute(request.SysID, request.UserAD, request.Environment);
    }
    catch (Exception ex)
    {
        response.Result_code = Codes.SYSTEM_ERROR;
        response.Msg = "系統錯誤：" + ex.Message;
    }
    return JsonConvert.SerializeObject(response);
}


⸻

DLL 端 (Factory/FGetUserNameAndGroup.cs)

internal class FGetUserNameAndGroup
{
    internal GetUserNameAndGroupModel.GetUserNameAndGroupResponse Execute(string sysId, string userAd, string environment)
    {
        var response = new GetUserNameAndGroupModel.GetUserNameAndGroupResponse();
        try
        {
            // 把 AD 轉成員編
            string empNo = FIdentity.GetEmpNoByAD(userAd, environment);

            using (SqlConnection conn = new SqlConnection(FCommon.BuildConnectionString(environment)))
            {
                conn.Open();
                string sql = @"
                SELECT TOP 1
                       B.U_ID AS UserID,
                       B.U_NAME AS UserName,
                       A.APG_NO AS GroupID,
                       A.APG_NAME AS GroupName,
                       A.PARENT_APG_NO,
                       A.SENSITIVE_DATA_ACCESS,
                       M.ORGAN_CAP AS OrganName,
                       M.POST_NAME AS PostName
                FROM [HI_TMMAIN].[dbo].[AP_GROUP] A
                LEFT JOIN [AP_USER] B ON A.APG_NO = B.APG_NO
                LEFT JOIN [DB_SHARE].[dbo].[M1EMP_MAST] M ON B.U_ID = M.EMP_NO
                WHERE A.SYS_ID=@SysID AND B.U_ID=@EmpNo";

                using (SqlCommand cmd = new SqlCommand(sql, conn))
                {
                    cmd.Parameters.AddWithValue("@SysID", sysId);
                    cmd.Parameters.AddWithValue("@EmpNo", empNo);

                    using (var reader = cmd.ExecuteReader())
                    {
                        if (reader.Read())
                        {
                            response.Result_code = Codes.SUCCESS;
                            response.Msg = "成功";
                            response.Result = new GetUserNameAndGroupModel.ResultData
                            {
                                UserID = reader["UserID"].ToString(),
                                UserName = reader["UserName"].ToString(),
                                GroupID = reader["GroupID"].ToString(),
                                GroupName = reader["GroupName"].ToString(),
                                SensitiveDataAccess = Convert.ToBoolean(reader["SENSITIVE_DATA_ACCESS"]),
                                OrganName = reader["OrganName"].ToString(),
                                PostName = reader["PostName"].ToString(),
                                ParentGroupID = new List<string> { reader["PARENT_APG_NO"].ToString() }
                            };
                        }
                        else
                        {
                            response.Result_code = Codes.NO_PERMISSION;
                            response.Msg = "查無權限";
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            response.Result_code = Codes.SYSTEM_ERROR;
            response.Msg = "系統錯誤：" + ex.Message;
        }
        return response;
    }
}


⸻

Web 專案 Request/Response Model (M_AP.cs)

public class GetUserNameAndGroupRequestModel
{
    public string SysID { get; set; }
    public string UserAD { get; set; }
    public string Environment { get; set; }
}

public class GetUserNameAndGroupResponseModel
{
    public string Result_code { get; set; }
    public string Msg { get; set; }
    public ResultData Result { get; set; }

    public class ResultData
    {
        public string UserID { get; set; }
        public string UserName { get; set; }
        public string GroupID { get; set; }
        public string GroupName { get; set; }
        public List<string> ParentGroupID { get; set; }
        public List<string> ChildGroupID { get; set; }
        public bool SensitiveDataAccess { get; set; }
        public string OrganName { get; set; }
        public string PostName { get; set; }
    }
}


⸻

Web 專案測試 Controller

public ActionResult Test_GetUserNameAndGroup()
{
    var req = new POSFILE_APPLY.Models.M_AP.GetUserNameAndGroupRequestModel
    {
        SysID = "HI_POSIMG",
        UserAD = "3A001",   // 測試用 AD
        Environment = "TEST"
    };

    string jsonInput = JsonConvert.SerializeObject(req);
    string response = new HI_APACCESS_DLL_FRAMEWORK.APACCESS().GetUserNameAndGroup(jsonInput);
    var res = JsonConvert.DeserializeObject<POSFILE_APPLY.Models.M_AP.GetUserNameAndGroupResponseModel>(response);

    return Content($"<pre>{JsonConvert.SerializeObject(res, Formatting.Indented)}</pre>", "text/html");
}


⸻

✅ 這樣功能 1 的 DLL + Factory + Web 測試就全套跑得起來。

⸻

要不要我接下來幫你把 Get_資料面最高權限 拉出來規劃成「功能 7」的 DLL API（跟 1~5 分開），這樣就不會誤會它跟功能 5 有關？