我理解您的問題。Fortify 掃描出 “Access Control: Database” 問題,主要是因為 `apgNo` 參數直接用於 SQL 查詢,可能存在權限控制風險。讓我提供幾個解決方案:

## 解決方案 1: 使用 Service 層進行參數化查詢(推薦)

修改您的 `F_AP.cs`,使用現有的 `SVS_DBmanager`:

```csharp
// F_AP.cs - 修改後的方法
public ImportResult ImportUsersFromExcel(string filePath, string sysId, string apgNo, string creator)
{
    ImportResult result = new ImportResult()
    {
        ErrorMessages = new List<ImportError>()
    };

    try
    {
        var dbManager = new SVS_DBmanager();
        
        // **1. 驗證權限**
        if (!HasGroupPermissionViaSP(dbManager, sysId, apgNo, creator))
        {
            result.IsSuccess = false;
            result.ErrorMessage = "無權限操作此群組";
            return result;
        }

        // **2. 驗證群組存在**
        var validateParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.NVarChar, 50) { Value = sysId },
            new SqlParameter("@APG_NO", SqlDbType.NVarChar, 50) { Value = apgNo }
        };
        
        string validateGroupSql = "SELECT COUNT(1) FROM AP_GROUP WHERE SYS_ID=@SYS_ID AND APG_NO=@APG_NO";
        var validateResult = dbManager.QueryBySQL(validateGroupSql, validateParams);
        
        if (validateResult.Rows.Count == 0 || Convert.ToInt32(validateResult.Rows[0][0]) == 0)
        {
            result.IsSuccess = false;
            result.ErrorMessage = "群組不存在";
            return result;
        }

        // **3. 讀取 Excel**
        var rows = ReadExcelData(filePath, result);
        if (!result.IsSuccess || rows == null) return result;

        // **4. 批次處理每筆資料**
        int successCount = 0;
        foreach (var row in rows)
        {
            if (ProcessUserRow(dbManager, row, sysId, apgNo, creator, result))
            {
                successCount++;
            }
        }

        result.SuccessCount = successCount;
        result.IsSuccess = true;
    }
    catch (Exception ex)
    {
        result.IsSuccess = false;
        result.ErrorMessage = "處理 Excel 匯入時發生錯誤：" + ex.Message;
    }

    return result;
}

/// <summary>
/// 使用參數化查詢檢查權限
/// </summary>
private bool HasGroupPermissionViaSP(SVS_DBmanager dbManager, string sysId, string targetApgNo, string userId)
{
    try
    {
        var parameters = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.NVarChar, 50) { Value = sysId },
            new SqlParameter("@APG_NO", SqlDbType.NVarChar, 50) { Value = targetApgNo },
            new SqlParameter("@U_ID", SqlDbType.NVarChar, 50) { Value = userId }
        };

        string permissionCheckSql = @"
            SELECT 
                CASE 
                    WHEN EXISTS (
                        SELECT 1 FROM AP_USER 
                        WHERE SYS_ID = @SYS_ID AND APG_NO = '001' AND U_ID = @U_ID
                    ) THEN 1
                    WHEN EXISTS (
                        SELECT 1 FROM AP_GROUP 
                        WHERE SYS_ID = @SYS_ID AND APG_NO = @APG_NO AND CREATOR = @U_ID
                    ) THEN 1
                    WHEN EXISTS (
                        SELECT 1 FROM AP_USER 
                        WHERE SYS_ID = @SYS_ID AND APG_NO = @APG_NO AND U_ID = @U_ID
                    ) THEN 1
                    ELSE 0
                END AS HasPermission";

        var result = dbManager.QueryBySQL(permissionCheckSql, parameters);
        
        return result.Rows.Count > 0 && Convert.ToInt32(result.Rows[0]["HasPermission"]) == 1;
    }
    catch (Exception ex)
    {
        // Log error
        return false;
    }
}

/// <summary>
/// 讀取 Excel 資料
/// </summary>
private List<(int RowNumber, string EmpNo)> ReadExcelData(string filePath, ImportResult result)
{
    var rows = new List<(int RowNumber, string EmpNo)>();
    
    try
    {
        using (var stream = File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.Read))
        using (var reader = ExcelReaderFactory.CreateReader(stream))
        {
            int rowIndex = 0;
            while (reader.Read())
            {
                rowIndex++;

                // 檢查表頭
                if (rowIndex == 1)
                {
                    string header = reader.GetString(0)?.Trim();
                    if (string.IsNullOrEmpty(header) || header != "員工編號")
                    {
                        result.IsSuccess = false;
                        result.ErrorMessage = "Excel 格式錯誤：第一列第一欄必須是「員工編號」";
                        return null;
                    }
                    continue;
                }

                string empNo = reader.GetValue(0)?.ToString().Trim();
                if (!string.IsNullOrEmpty(empNo))
                {
                    rows.Add((rowIndex, empNo));
                }
            }
        }

        if (rows.Count == 0)
        {
            result.IsSuccess = false;
            result.ErrorMessage = "Excel 無任何員工資料";
            return null;
        }

        return rows;
    }
    catch (Exception ex)
    {
        result.IsSuccess = false;
        result.ErrorMessage = "讀取 Excel 時發生錯誤：" + ex.Message;
        return null;
    }
}

/// <summary>
/// 處理單筆員工資料
/// </summary>
private bool ProcessUserRow(SVS_DBmanager dbManager, (int RowNumber, string EmpNo) row, 
                            string sysId, string apgNo, string creator, ImportResult result)
{
    try
    {
        // 1. 檢查員工是否存在
        var empParams = new List<SqlParameter>
        {
            new SqlParameter("@EMP_NO", SqlDbType.NVarChar, 50) { Value = row.EmpNo }
        };
        
        string checkEmpSql = "SELECT EMP_NAME FROM [HILIFE_DB3].[DB_SHARE].dbo.[M1EMP_MAST] WHERE EMP_NO=@EMP_NO";
        var empResult = dbManager.QueryBySQL(checkEmpSql, empParams);
        
        if (empResult.Rows.Count == 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "查無此員工"
            });
            return false;
        }
        
        string empName = empResult.Rows[0]["EMP_NAME"].ToString();

        // 2. 檢查是否已存在於同一個群組
        var checkUserParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.NVarChar, 50) { Value = sysId },
            new SqlParameter("@APG_NO", SqlDbType.NVarChar, 50) { Value = apgNo },
            new SqlParameter("@U_ID", SqlDbType.NVarChar, 50) { Value = row.EmpNo }
        };
        
        string checkUserSql = "SELECT COUNT(1) FROM AP_USER WHERE SYS_ID=@SYS_ID AND APG_NO=@APG_NO AND U_ID=@U_ID";
        var userResult = dbManager.QueryBySQL(checkUserSql, checkUserParams);
        
        if (Convert.ToInt32(userResult.Rows[0][0]) > 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "此群組已存在該員工"
            });
            return false;
        }

        // 3. 檢查是否已存在於該系統的其他群組
        var checkSystemParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.NVarChar, 50) { Value = sysId },
            new SqlParameter("@APG_NO", SqlDbType.NVarChar, 50) { Value = apgNo },
            new SqlParameter("@U_ID", SqlDbType.NVarChar, 50) { Value = row.EmpNo }
        };
        
        string checkSystemSql = "SELECT COUNT(1) FROM AP_USER WHERE SYS_ID=@SYS_ID AND APG_NO<>@APG_NO AND U_ID=@U_ID";
        var systemResult = dbManager.QueryBySQL(checkSystemSql, checkSystemParams);
        
        if (Convert.ToInt32(systemResult.Rows[0][0]) > 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "此系統其他群組已存在該員工"
            });
            return false;
        }

        // 4. 寫入 AP_USER
        var insertParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.NVarChar, 50) { Value = sysId },
            new SqlParameter("@APG_NO", SqlDbType.NVarChar, 50) { Value = apgNo },
            new SqlParameter("@U_ID", SqlDbType.NVarChar, 50) { Value = row.EmpNo },
            new SqlParameter("@U_NAME", SqlDbType.NVarChar, 100) { Value = empName },
            new SqlParameter("@CREATOR", SqlDbType.NVarChar, 50) { Value = creator }
        };

        string insertSql = @"
            INSERT INTO AP_USER(SYS_ID, APG_NO, U_ID, U_NAME, CREATOR, CREATE_TIME)
            VALUES(@SYS_ID, @APG_NO, @U_ID, @U_NAME, @CREATOR, GETDATE())";

        dbManager.ExecuteSQL(insertSql, insertParams);
        return true;
    }
    catch (Exception exRow)
    {
        result.ErrorMessages.Add(new ImportError
        {
            RowNumber = row.RowNumber,
            EmpNo = row.EmpNo,
            Message = "寫入錯誤：" + exRow.Message
        });
        return false;
    }
}
```

## 解決方案 2: 建立 Stored Procedure (最安全)

在資料庫中建立 SP,將權限檢查邏輯封裝:

```sql
CREATE PROCEDURE [dbo].[USP_CheckGroupPermission]
    @SYS_ID NVARCHAR(50),
    @APG_NO NVARCHAR(50),
    @U_ID NVARCHAR(50)
AS
BEGIN
    SELECT 
        CASE 
            WHEN EXISTS (
                SELECT 1 FROM AP_USER 
                WHERE SYS_ID = @SYS_ID AND APG_NO = '001' AND U_ID = @U_ID
            ) THEN 1
            WHEN EXISTS (
                SELECT 1 FROM AP_GROUP 
                WHERE SYS_ID = @SYS_ID AND APG_NO = @APG_NO AND CREATOR = @U_ID
            ) THEN 1
            WHEN EXISTS (
                SELECT 1 FROM AP_USER 
                WHERE SYS_ID = @SYS_ID AND APG_NO = @APG_NO AND U_ID = @U_ID
            ) THEN 1
            ELSE 0
        END AS HasPermission
END
```

然後在程式中呼叫:

```csharp
private bool HasGroupPermissionViaSP(SVS_DBmanager dbManager, string sysId, string targetApgNo, string userId)
{
    var parameters = new List<SqlParameter>
    {
        new SqlParameter("@SYS_ID", SqlDbType.NVarChar, 50) { Value = sysId },
        new SqlParameter("@APG_NO", SqlDbType.NVarChar, 50) { Value = targetApgNo },
        new SqlParameter("@U_ID", SqlDbType.NVarChar, 50) { Value = userId }
    };

    var result = dbManager.QueryBySQL("EXEC USP_CheckGroupPermission @SYS_ID, @APG_NO, @U_ID", parameters);
    return result.Rows.Count > 0 && Convert.ToInt32(result.Rows[0]["HasPermission"]) == 1;
}
```

## 關鍵改善點:

1. ✅ **完全使用參數化查詢** - 所有 SQL 都透過 `SqlParameter` 傳遞
1. ✅ **使用現有的 Service 層** - 統一透過 `SVS_DBmanager` 操作資料庫
1. ✅ **定義參數大小** - `SqlDbType.NVarChar, 50` 限制輸入長度
1. ✅ **權限先行驗證** - 在任何資料庫操作前先檢查權限
1. ✅ **程式碼模組化** - 將邏輯拆分成小方法,易於維護和測試

這樣修改後,Fortify 應該就不會再報 Access Control 問題了。建議採用**解決方案 1**,因為它充分利用了您現有的 Service 架構。​​​​​​​​​​​​​​​​