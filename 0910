沒問題～我們從頭把「設計 → 要改哪些檔 → 實作程式碼 → 怎麼測」一次講清楚，讓你不會亂 😊

⸻

0) 你要達成的目標（一句話）
	•	外部系統都只傳 AD（UserAD）給 DLL
	•	DLL 先把 AD 轉員編 (EMP_NO)，再執行你規格中的功能（1～5）。
	•	對外 API 的資料結構維持你原本的規格不變（功能1回傳 UserID=員編）。

⸻

1) 專案內檔案結構（新增與調整）

HI_APACCESS_DLL_FRAMEWORK/
├── Common/
│   └── FCommon.cs                // 已有：環境連線字串、授權系統清單
├── Factory/
│   ├── FIdentity.cs              // ✅ 新增：AD → EMP_NO 一站式轉換
│   ├── FGetUserNameAndGroup.cs   // ✅ 修改：改成先把 AD 轉 EMP_NO 再查
│   ├── FGetGroupAllUser.cs       // (已完成)
│   ├── FGetTree.cs               // (已完成)
│   ├── FGetFuncBtn.cs            // (已完成)
│   └── FCheckBtnEnabled.cs       // (已完成, 已修正用 FUNC_ID+BTNSEQ)
├── Models/
│   └── GetUserNameAndGroupModel.cs // ✅ 確認欄位、JsonProperty、DisplayName
└── APACCESS.cs                   // ✅ 主類別：新增 ResolveEmpNoByAD() 工具方法；功能1使用它


⸻

2) 共用工具：AD→員編放進 DLL（新增 FIdentity.cs）

用你提供的 SQL，直接在 DLL 內做轉換。
之後不管功能1或別的，需要員編就用這個方法。

// Factory/FIdentity.cs
using System.Data.SqlClient;
using HI_APACCESS_DLL_FRAMEWORK.Common;

namespace HI_APACCESS_DLL_FRAMEWORK.Factory
{
    internal static class FIdentity
    {
        /// <summary>AD → 員編（查不到時回傳原 AD）</summary>
        internal static string GetEmpNoByAD(string ad, string environment)
        {
            if (string.IsNullOrWhiteSpace(ad)) return ad;

            // 你的 SQL（跨 DB join 在同一 SQL Server 上）
            string sql = @"
SELECT EMP_ID 
FROM [HILIFE_MTS].[HI_APUSER].dbo.[NT_EMP] 
WHERE EMP_ID != EMP_DOM_ID
  AND LTRIM(RTRIM(EMP_DOM_ID)) <> '' 
  AND EMP_ID IN (
        SELECT EMP_NO 
        FROM [HILIFE_DB3].[DB_SHARE].dbo.[M1EMP_MAST] 
        WHERE END_DT IS NULL
  ) 
  AND EMP_DOM_ID = @AD";

            string empNo = null;
            using (var conn = new SqlConnection(FCommon.BuildConnectionString(environment)))
            using (var cmd  = new SqlCommand(sql, conn))
            {
                cmd.Parameters.AddWithValue("@AD", ad);
                conn.Open();
                var o = cmd.ExecuteScalar();
                empNo = o?.ToString();
            }

            return string.IsNullOrWhiteSpace(empNo) ? ad : empNo;
        }
    }
}

✅ 假設 TEST/PROD 兩個環境的 同一台 SQL Server 上都能存取這三個 DB（HILIFE_MTS、HILIFE_DB3、HI_TMMAIN）。
若 PROD 要用不同 DataSource，請在 FCommon.BuildConnectionString(environment) 已經完成切換（你前面有做）。

⸻

3) 主類別新增工具方法（APACCESS.cs）

這不是新的業務 API，只是工具方法（直接回傳字串），方便內外部程式在必要時單純轉換 AD→員編。

// APACCESS.cs (節錄)
using HI_APACCESS_DLL_FRAMEWORK.Factory;

namespace HI_APACCESS_DLL_FRAMEWORK
{
    public class APACCESS
    {
        /// <summary>工具方法：AD 轉員編</summary>
        public string ResolveEmpNoByAD(string userAd, string environment)
        {
            return FIdentity.GetEmpNoByAD(userAd, environment);
        }

        // ... 其餘功能1～6
    }
}


⸻

4) 功能 1 的 Model（GetUserNameAndGroupModel.cs）

保持你規格；回傳 UserID=員編。
（下面示範用 Pascal 命名＋JsonProperty，避免大小寫不一致）

// Models/GetUserNameAndGroupModel.cs
using Newtonsoft.Json;
using System.Collections.Generic;
using System.ComponentModel;

namespace HI_APACCESS_DLL_FRAMEWORK.Models
{
    internal class GetUserNameAndGroupModel
    {
        internal class GetUserNameAndGroupRequest
        {
            [JsonProperty("SysID")]
            [DisplayName("系統ID")]
            internal string SysID { get; set; }

            [JsonProperty("UserAD")]
            [DisplayName("使用者AD")]
            internal string UserAD { get; set; }

            [JsonProperty("Environment")]
            [DisplayName("環境")]
            internal string Environment { get; set; }
        }

        internal class GetUserNameAndGroupResponse
        {
            [JsonProperty("Result_code")]
            [DisplayName("回覆代碼")]
            internal string Result_code { get; set; }

            [JsonProperty("Msg")]
            [DisplayName("訊息")]
            internal string Msg { get; set; }

            [JsonProperty("Result")]
            [DisplayName("回應內容")]
            internal ResultData Result { get; set; }
        }

        internal class ResultData
        {
            [JsonProperty("UserID")]
            [DisplayName("員編")]
            internal string UserID { get; set; }

            [JsonProperty("UserName")]
            [DisplayName("姓名")]
            internal string UserName { get; set; }

            [JsonProperty("GroupID")]
            [DisplayName("群組代碼")]
            internal string GroupID { get; set; }

            [JsonProperty("GroupName")]
            [DisplayName("群組名稱")]
            internal string GroupName { get; set; }

            [JsonProperty("ParentGroupID")]
            [DisplayName("母群組清單")]
            internal List<string> ParentGroupID { get; set; }

            [JsonProperty("ChildGroupID")]
            [DisplayName("子群組清單")]
            internal List<string> ChildGroupID { get; set; }

            [JsonProperty("SensitiveDataAccess")]
            [DisplayName("機敏資料權限")]
            internal bool SensitiveDataAccess { get; set; }

            [JsonProperty("OrganName")]
            [DisplayName("部門")]
            internal string OrganName { get; set; }

            [JsonProperty("PostName")]
            [DisplayName("職稱")]
            internal string PostName { get; set; }
        }
    }
}


⸻

5) 功能 1 Factory（FGetUserNameAndGroup.cs）

重點：先把 AD 轉員編，再查。母群組直接用欄位（若你那邊存的是「001,002」就 split），子群組用你定義的邏輯查。

// Factory/FGetUserNameAndGroup.cs
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using HI_APACCESS_DLL_FRAMEWORK.Models;
using HI_APACCESS_DLL_FRAMEWORK.Common;

namespace HI_APACCESS_DLL_FRAMEWORK.Factory
{
    internal class FGetUserNameAndGroup
    {
        internal GetUserNameAndGroupModel.GetUserNameAndGroupResponse Execute(string sysId, string userAd, string environment)
        {
            var res = new GetUserNameAndGroupModel.GetUserNameAndGroupResponse();

            try
            {
                // 0) 環境檢查
                if (environment != "TEST" && environment != "PROD")
                {
                    res.Result_code = Codes.ENV_ERROR;
                    res.Msg = "環境錯誤，只接受 TEST 或 PROD";
                    return res;
                }

                // 1) 系統授權檢查
                var authorized = FCommon.GetAuthorizedSystemsList(environment);
                if (!authorized.Contains(sysId))
                {
                    res.Result_code = Codes.SYS_UNAUTHORIZED;
                    res.Msg = "系統未授權";
                    return res;
                }

                // 2) AD → 員編
                string empNo = FIdentity.GetEmpNoByAD(userAd, environment);

                // 3) 查使用者基本＋群組（用員編）
                string groupId = null;
                string groupName = null;
                bool sensitive = false;
                string userName = null;
                string parentRaw = null;
                string organ = null;
                string post = null;

                using (var conn = new SqlConnection(FCommon.BuildConnectionString(environment)))
                {
                    conn.Open();

                    // 3-1 主要資料（UserName, GroupID/Name, Sensitive, ParentGroup raw, 部門/職稱）
                    string sqlMain = @"
SELECT TOP 1
    B.U_ID           AS UserID,
    B.U_NAME         AS UserName,
    A.APG_NO         AS GroupID,
    A.APG_NAME       AS GroupName,
    A.PARENT_APG_NO  AS ParentRaw,
    A.SENSITIVE_DATA_ACCESS AS SensitiveDataAccess,
    M.ORGAN_CAP      AS OrganName,
    M.POST_NAME      AS PostName
FROM [HI_TMMAIN].[dbo].[AP_GROUP] A
LEFT JOIN [HI_TMMAIN].[dbo].[AP_USER] B  ON A.APG_NO = B.APG_NO
LEFT JOIN [HILIFE_DB3].[DB_SHARE].dbo.[M1EMP_MAST] M ON B.U_ID = M.EMP_NO
WHERE A.SYS_ID=@SYS_ID AND B.U_ID=@EMP_NO";

                    using (var cmd = new SqlCommand(sqlMain, conn))
                    {
                        cmd.Parameters.AddWithValue("@SYS_ID", sysId);
                        cmd.Parameters.AddWithValue("@EMP_NO", empNo);

                        using (var r = cmd.ExecuteReader())
                        {
                            if (r.Read())
                            {
                                // 主要欄位
                                userName  = r["UserName"]?.ToString();
                                groupId   = r["GroupID"]?.ToString();
                                groupName = r["GroupName"]?.ToString();
                                parentRaw = r["ParentRaw"]?.ToString();
                                sensitive = r["SensitiveDataAccess"] != DBNull.Value && Convert.ToBoolean(r["SensitiveDataAccess"]);
                                organ     = r["OrganName"]?.ToString();
                                post      = r["PostName"]?.ToString();
                            }
                        }
                    }

                    if (string.IsNullOrWhiteSpace(groupId))
                    {
                        res.Result_code = Codes.NO_PERMISSION;
                        res.Msg = "查無權限";
                        return res;
                    }

                    // 3-2 母群組：如果資料表直接存 "003,002" 這種，就 split；如果是單一值就包成清單
                    var parentList = new List<string>();
                    if (!string.IsNullOrWhiteSpace(parentRaw))
                    {
                        foreach (var s in parentRaw.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries))
                            parentList.Add(s.Trim());
                    }

                    // 3-3 子群組：同 SYS_ID，PARENT_APG_NO 包含我的 GroupID 的群組
                    // 若 PARENT_APG_NO 可能存多碼（逗號分隔），用 like 包逗號防止誤判
                    var childList = new List<string>();
                    string sqlChild = @"
SELECT APG_NO 
FROM [HI_TMMAIN].[dbo].[AP_GROUP]
WHERE SYS_ID=@SYS_ID
  AND (',' + LTRIM(RTRIM(PARENT_APG_NO)) + ',') LIKE '%,' + @MY_GID + ',%'";

                    using (var cmd2 = new SqlCommand(sqlChild, conn))
                    {
                        cmd2.Parameters.AddWithValue("@SYS_ID", sysId);
                        cmd2.Parameters.AddWithValue("@MY_GID", groupId);

                        using (var r2 = cmd2.ExecuteReader())
                        {
                            while (r2.Read())
                            {
                                childList.Add(r2["APG_NO"].ToString());
                            }
                        }
                    }

                    // 4) 組回應
                    res.Result_code = Codes.SUCCESS;
                    res.Msg = "成功";
                    res.Result = new GetUserNameAndGroupModel.ResultData
                    {
                        UserID             = empNo,      // ✅ 回傳員編
                        UserName           = userName,
                        GroupID            = groupId,
                        GroupName          = groupName,
                        ParentGroupID      = parentList,
                        ChildGroupID       = childList,
                        SensitiveDataAccess= sensitive,
                        OrganName          = organ,
                        PostName           = post
                    };
                }
            }
            catch (Exception ex)
            {
                res.Result_code = Codes.SYSTEM_ERROR;
                res.Msg = "系統錯誤：" + ex.Message;
            }

            return res;
        }
    }
}


⸻

6) 功能 1 主類別呼叫（APACCESS.cs）

這邏輯維持簡單：反序列化 → 交給 Factory → 序列化回傳。
Factory 裡面已經會把 AD 轉員編了。

// APACCESS.cs (節錄)
using Newtonsoft.Json;
using HI_APACCESS_DLL_FRAMEWORK.Models;
using HI_APACCESS_DLL_FRAMEWORK.Factory;
using HI_APACCESS_DLL_FRAMEWORK.Common;

namespace HI_APACCESS_DLL_FRAMEWORK
{
    public class APACCESS
    {
        public string GetUserNameAndGroup(string requestJson)
        {
            var response = new GetUserNameAndGroupModel.GetUserNameAndGroupResponse();

            try
            {
                var request = JsonConvert.DeserializeObject<GetUserNameAndGroupModel.GetUserNameAndGroupRequest>(requestJson);
                var func = new FGetUserNameAndGroup();
                response = func.Execute(request.SysID, request.UserAD, request.Environment);
            }
            catch (Exception ex)
            {
                response = new GetUserNameAndGroupModel.GetUserNameAndGroupResponse
                {
                    Result_code = Codes.SYSTEM_ERROR,
                    Msg = "系統錯誤：" + ex.Message
                };
            }

            return JsonConvert.SerializeObject(response);
        }

        // 工具：AD→員編
        public string ResolveEmpNoByAD(string userAd, string environment)
        {
            return FIdentity.GetEmpNoByAD(userAd, environment);
        }
    }
}


⸻

7) Web 專案：測試用 Controller + Model

Controller（APController.cs）

using System.Web.Mvc;
using Newtonsoft.Json;
using HI_APACCESS_DLL_FRAMEWORK;
using POSFILE_APPLY.Models;

public class APController : Controller
{
    // 測試：功能1 取得使用者群組與名稱（輸入 AD）
    public ActionResult Test_GetUserNameAndGroup()
    {
        var req = new M_AP.GetUserNameAndGroupRequestModel
        {
            SysID = "HI_POSIMG",
            UserAD = "3A001",   // 測試 AD
            Environment = "TEST"
        };

        string jsonInput = JsonConvert.SerializeObject(req);
        string response = new APACCESS().GetUserNameAndGroup(jsonInput);
        var res = JsonConvert.DeserializeObject<M_AP.GetUserNameAndGroupResponseModel>(response);

        return Content($"<pre>{JsonConvert.SerializeObject(res, Formatting.Indented)}</pre>", "text/html");
    }
}

Web 測試用 Model（POSFILE_APPLY.Models.M_AP）

using System.Collections.Generic;

namespace POSFILE_APPLY.Models
{
    public class M_AP
    {
        // 功能1：Request
        public class GetUserNameAndGroupRequestModel
        {
            public string SysID { get; set; }
            public string UserAD { get; set; }
            public string Environment { get; set; }
        }

        // 功能1：Response
        public class GetUserNameAndGroupResponseModel
        {
            public string Result_code { get; set; }
            public string Msg { get; set; }
            public ResultData Result { get; set; }

            public class ResultData
            {
                public string UserID { get; set; }               // 員編
                public string UserName { get; set; }
                public string GroupID { get; set; }
                public string GroupName { get; set; }
                public List<string> ParentGroupID { get; set; }
                public List<string> ChildGroupID { get; set; }
                public bool SensitiveDataAccess { get; set; }
                public string OrganName { get; set; }
                public string PostName { get; set; }
            }
        }
    }
}


⸻

8) Hi_Btn 以後怎麼寫？（重點邏輯）

「要不要顯示某顆按鈕」＝「群組是否對那個頁面的那顆按鈕有權限」。
直接呼叫 DLL 功能 5（CheckBtnEnabled）即可，不要自己打 SQL。

// 範例 HtmlHelper：@Html.Hi_Btn("POS1001", "001", "EDIT", "編輯", "button", new { @class="btn" })
public static class CustomHtmlHelpers
{
    public static MvcHtmlString Hi_Btn(this HtmlHelper helper,
        string funcId, string groupId, string btnId,
        string text, string type, object htmlAttributes)
    {
        // 呼叫 DLL 功能5
        var req = new POSFILE_APPLY.Models.M_AP.CheckBtnEnabledRequestModel
        {
            SysID = "HI_POSIMG",
            GroupID = groupId,
            FuncID = funcId,
            BtnID = btnId,
            Environment = "TEST"
        };

        string json = JsonConvert.SerializeObject(req);
        string raw  = new HI_APACCESS_DLL_FRAMEWORK.APACCESS().CheckBtnEnabled(json);
        var res     = JsonConvert.DeserializeObject<POSFILE_APPLY.Models.M_AP.CheckBtnEnabledResponseModel>(raw);

        if (!res.Result) return null; // 沒權限就不顯示

        // 有權限 → 產 button
        var tb = new TagBuilder("button");
        if (!string.IsNullOrWhiteSpace(text)) tb.InnerHtml = text;
        if (!string.IsNullOrWhiteSpace(btnId)) tb.Attributes["id"] = btnId;
        if (!string.IsNullOrWhiteSpace(type)) tb.Attributes["type"] = type;

        if (htmlAttributes != null)
        {
            var dict = JsonConvert.DeserializeObject<Dictionary<string,string>>(
                JsonConvert.SerializeObject(htmlAttributes));
            foreach (var kv in dict)
            {
                var key = kv.Key.Replace("_", "-");
                tb.Attributes[key] = kv.Value;
            }
        }
        return MvcHtmlString.Create(tb.ToString());
    }
}

✅ 這樣改完後，Button 權限完全交給 DLL 管，Web 不再打任何權限 SQL。

⸻

9) 「Get_資料面最高權限」不是功能 5

你的 SQL（MRSUPPER）是資料層級的權限，不是按鈕權限。
→ 它應該是另一支 API（例如功能 7）：輸入 Emp_NO，回傳 true/false。
目前先不動（等你確認要不要也放進 DLL）。

⸻

10) 測試流程（一步步）
	1.	建置 DLL（HI_APACCESS_DLL_FRAMEWORK）→ 確認 .dll 出現在 Web 專案 bin。
	2.	Web 加上 APController.Test_GetUserNameAndGroup 與 Web 模型。
	3.	瀏覽器打：/AP/Test_GetUserNameAndGroup
	•	成功會看到：

{
  "Result_code": "0000",
  "Msg": "成功",
  "Result": {
    "UserID": "E12345",
    "UserName": "王小明",
    "GroupID": "001",
    "GroupName": "管理員(資訊)",
    "ParentGroupID": ["003","002"],
    "ChildGroupID": ["004","005"],
    "SensitiveDataAccess": false,
    "OrganName": "程式課",
    "PostName": "高級專員"
  }
}


	•	查不到 → 0001 查無權限
	•	環境錯誤 → 1003 環境錯誤

	4.	頁面按鈕（Hi_Btn）驗證：把你頁面的 @Html.Hi_Btn(...) 改成新版本，對照功能 5 的資料檔。

⸻

最後的提醒
	•	環境連線字串：FCommon.BuildConnectionString(environment) 要能存取你三個 DB，否則 FIdentity 查不到員編。
	•	母群組：你說「母群組可以直接撈」→ 用 PARENT_APG_NO；若是逗號分隔，就 split。
	•	子群組：用 LIKE 包逗號避免誤判（如果 PARENT_APG_NO 允許多值）。

⸻

如果你想，我也可以把 功能 2～5 全部再掃一遍，確認是否也需要 AD→員編（通常不需要，因為 2～5 都是 GroupID 驅動），並補上測試 Controller。


