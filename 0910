了解 👌 你現在想直接在 SQL Server 裡測試「功能樹狀結構」，確認不同使用者 (AD → 員編 → 群組) 出來的目錄是否一致。

我幫你整理一個 長出完整功能樹的 SQL，直接在 SSMS 可以跑：

⸻

SQL：產生功能樹 (依群組取功能)

;WITH FuncCTE AS
(
    SELECT 
        f.FUNC_ID,
        f.PARENT_ID,
        f.FUNC_NA,
        f.SORT_NO,
        f.VIEW_H,
        f.VIEW_HB,
        0 AS LEVEL,
        CAST(f.FUNC_ID AS VARCHAR(MAX)) AS PATH
    FROM [HI_TMMAIN].[dbo].[AP_FUNC] f
    INNER JOIN [HI_TMMAIN].[dbo].[AP_USER_FUNC_CONFIG] u
        ON f.SYS_ID = u.SYS_ID AND f.FUNC_ID = u.FUNC_ID
    WHERE f.SYS_ID = @SysID
      AND u.APG_NO = @GroupID
      AND f.IS_SHOW = 'Y'                 -- 只顯示需要顯示的頁面
      AND (f.PARENT_ID IS NULL OR f.PARENT_ID = 'HOME')

    UNION ALL

    SELECT 
        f.FUNC_ID,
        f.PARENT_ID,
        f.FUNC_NA,
        f.SORT_NO,
        f.VIEW_H,
        f.VIEW_HB,
        c.LEVEL + 1,
        CAST(c.PATH + '>' + f.FUNC_ID AS VARCHAR(MAX)) AS PATH
    FROM [HI_TMMAIN].[dbo].[AP_FUNC] f
    INNER JOIN [HI_TMMAIN].[dbo].[AP_USER_FUNC_CONFIG] u
        ON f.SYS_ID = u.SYS_ID AND f.FUNC_ID = u.FUNC_ID
    INNER JOIN FuncCTE c
        ON f.PARENT_ID = c.FUNC_ID
    WHERE f.SYS_ID = @SysID
      AND u.APG_NO = @GroupID
      AND f.IS_SHOW = 'Y'
)
SELECT 
    FUNC_ID,
    PARENT_ID,
    FUNC_NA,
    SORT_NO,
    VIEW_H,
    VIEW_HB,
    LEVEL,
    PATH
FROM FuncCTE
ORDER BY PATH;


⸻

使用方式
	1.	換掉參數：

DECLARE @SysID NVARCHAR(50) = 'HI_POSIMG';
DECLARE @GroupID NVARCHAR(50) = '007';  -- 群組編號（由員編對應查出來）


	2.	執行後結果會顯示：
	•	FUNC_ID = 功能代號
	•	FUNC_NA = 功能名稱
	•	LEVEL = 樹狀層級 (0=根目錄, 1=子節點 …)
	•	PATH = 完整路徑 (方便你 debug)

⸻

重點說明
	•	AP_FUNC = 功能定義表
	•	AP_USER_FUNC_CONFIG = 群組對應的功能授權
	•	IS_SHOW='Y' → 過濾掉隱藏的頁面
	•	主管的 AD → 員編 → 群組可能跟一般員工不一樣，所以會拿到不同的 GroupID，導致功能樹不一樣。

⸻

👉 建議你先：

SELECT * 
FROM [HI_TMMAIN].[dbo].[AP_USER] 
WHERE U_ID = '<員編>'

看這個員編對應到哪些 APG_NO，再丟進上面 SQL 測功能樹。

⸻

要不要我幫你寫一個 輸入 AD → 自動轉員編 → 找群組 → 長功能樹的完整 SQL？这样你一行就能跑，不用自己拆查詢。