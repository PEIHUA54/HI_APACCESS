我了解問題了！你想要在**新分頁開啟 TOKEN URL** 的同時，**當前頁面停留在原本的位置**，而不是導向到 Main 頁面。

問題在於 `window.location.href` 會立即改變當前頁面，導致使用者體驗不佳。

## 解決方案

有幾種方式可以處理：

### **方案A：只開新分頁，當前頁面不動（推薦）**

```csharp
// 權限管理導向 URL
public ActionResult AP_ACCESS_SYS()
{
    try
    {
        var req_para = new HI_APACCESS.Models.M_SYS.GetUrlRequsetModel()
        {
            SysID = "HI_APACCESS",
            Type = "2",
            Environment = "DEV"
        };

        string json_input = JsonConvert.SerializeObject(req_para);
        string response = new HI_APACCESS_DLL.APACCESS().GetFunctionAndAccessUrl(json_input);
        HI_APACCESS.Models.M_SYS.GetUrlResponseModel response_ = JsonConvert.DeserializeObject<HI_APACCESS.Models.M_SYS.GetUrlResponseModel>(response);

        if (response_.Result_code == "0000")
        {
            // 👇 只開新分頁，當前頁面關閉自己（回到上一頁的效果）
            string script = $@"
            <script>
               window.open('{response_.Url}', '_blank');
               window.close(); // 關閉當前分頁
               // 如果無法關閉（因為不是由 script 開啟的），則返回上一頁
               if (!window.closed) {{
                   window.history.back();
               }}
            </script>";
            return Content(script, "text/html");
        }
        else
        {
            return Content($"<script>alert('取得權限管理連結失敗：{response_.Msg}'); window.history.back();</script>", "text/html");
        }
    }
    catch (Exception ex)
    {
        return Content($"<script>alert('導向權限管理系統發生錯誤：{ex.Message}'); window.history.back();</script>", "text/html");
    }
}

// 系統頁面管理導向
public ActionResult AP_ACCESS_SYS_FUNC()
{
    try
    {
        var req_para = new HI_APACCESS.Models.M_SYS.GetUrlRequsetModel()
        {
            SysID = "HI_APACCESS",
            Type = "1",
            Environment = "DEV"
        };

        string json_input = JsonConvert.SerializeObject(req_para);
        string response = new HI_APACCESS_DLL.APACCESS().GetFunctionAndAccessUrl(json_input);
        HI_APACCESS.Models.M_SYS.GetUrlResponseModel response_ = JsonConvert.DeserializeObject<HI_APACCESS.Models.M_SYS.GetUrlResponseModel>(response);

        if (response_.Result_code == "0000")
        {
            string script = $@"
            <script>
               window.open('{response_.Url}', '_blank');
               window.close();
               if (!window.closed) {{
                   window.history.back();
               }}
            </script>";
            return Content(script, "text/html");
        }
        else
        {
            return Content($"<script>alert('取得頁面功能管理連結失敗：{response_.Msg}'); window.history.back();</script>", "text/html");
        }
    }
    catch (Exception ex)
    {
        return Content($"<script>alert('導向權限管理系統發生錯誤：{ex.Message}'); window.history.back();</script>", "text/html");
    }
}
```

### **方案B：用 AJAX 方式呼叫，完全不離開當前頁面**

如果你是從目錄樹點擊進入，可以改用 AJAX：

**修改 Controller 回傳 JSON：**

```csharp
// 權限管理導向 URL - JSON 版本
[HttpPost]
public JsonResult GetAccessUrl(string type)
{
    try
    {
        var req_para = new HI_APACCESS.Models.M_SYS.GetUrlRequsetModel()
        {
            SysID = "HI_APACCESS",
            Type = type, // "1" 或 "2"
            Environment = "DEV"
        };

        string json_input = JsonConvert.SerializeObject(req_para);
        string response = new HI_APACCESS_DLL.APACCESS().GetFunctionAndAccessUrl(json_input);
        HI_APACCESS.Models.M_SYS.GetUrlResponseModel response_ = JsonConvert.DeserializeObject<HI_APACCESS.Models.M_SYS.GetUrlResponseModel>(response);

        if (response_.Result_code == "0000")
        {
            return Json(new { success = true, url = response_.Url });
        }
        else
        {
            return Json(new { success = false, message = response_.Msg });
        }
    }
    catch (Exception ex)
    {
        return Json(new { success = false, message = ex.Message });
    }
}
```

**前端 JavaScript（在目錄樹或按鈕點擊事件）：**

```javascript
// 權限管理
$('#btn-access-sys').click(function() {
    $.ajax({
        url: '@Url.Action("GetAccessUrl", "SYS")',
        type: 'POST',
        data: { type: "2" },
        dataType: 'json',
        success: function(response) {
            if (response.success) {
                window.open(response.url, '_blank');
            } else {
                alert('取得權限管理連結失敗：' + response.message);
            }
        },
        error: function() {
            alert('導向權限管理系統發生錯誤');
        }
    });
});

// 頁面管理
$('#btn-func-sys').click(function() {
    $.ajax({
        url: '@Url.Action("GetAccessUrl", "SYS")',
        type: 'POST',
        data: { type: "1" },
        dataType: 'json',
        success: function(response) {
            if (response.success) {
                window.open(response.url, '_blank');
            } else {
                alert('取得頁面功能管理連結失敗：' + response.message);
            }
        },
        error: function() {
            alert('導向權限管理系統發生錯誤');
        }
    });
});
```

### **方案C：直接 Redirect 到新分頁 URL**

如果你的目標是讓使用者直接跳轉過去：

```csharp
public ActionResult AP_ACCESS_SYS()
{
    try
    {
        var req_para = new HI_APACCESS.Models.M_SYS.GetUrlRequsetModel()
        {
            SysID = "HI_APACCESS",
            Type = "2",
            Environment = "DEV"
        };

        string json_input = JsonConvert.SerializeObject(req_para);
        string response = new HI_APACCESS_DLL.APACCESS().GetFunctionAndAccessUrl(json_input);
        HI_APACCESS.Models.M_SYS.GetUrlResponseModel response_ = JsonConvert.DeserializeObject<HI_APACCESS.Models.M_SYS.GetUrlResponseModel>(response);

        if (response_.Result_code == "0000")
        {
            // 直接導向到 TOKEN URL（當前頁面跳轉）
            return Redirect(response_.Url);
        }
        else
        {
            TempData["ErrorMessage"] = $"取得權限管理連結失敗：{response_.Msg}";
            return RedirectToAction("Main", "Home");
        }
    }
    catch (Exception ex)
    {
        TempData["ErrorMessage"] = $"導向權限管理系統發生錯誤：{ex.Message}";
        return RedirectToAction("Main", "Home");
    }
}
```

## 我的建議

**推薦使用方案B（AJAX 方式）**，因為：

✅ **使用者體驗最好** - 當前頁面完全不動，只開新分頁  
✅ **不會有「空白頁面」** - 不會出現執行 script 的過渡頁面  
✅ **更彈性** - 可以在任何地方呼叫，不限於目錄樹  
✅ **錯誤處理更優雅** - 用 alert 提示，不會跳頁

如果你的目錄樹是透過連結 `<a href="...">` 點擊進入，那可以用方案A。

你比較想用哪一種方式？我可以幫你調整細節！😊​​​​​​​​​​​​​​​​