啊！我理解了！讓我重新整理：

## 正確的權限邏輯

1. **001 群組**：可以操作所有群組（包括 001 自己）
1. **非 001 群組**（例如 002）：

- ✅ 可以操作**所有非 001 的群組**（002, 003, 004…）
- ❌ **不能操作 001**

**白話說明：**

- 002 群組的人可以管理 002、003、004… 所有群組的使用者
- 但 002 不能碰 001 群組
- 只有 001 群組的人才能管理 001

## 修正後的 GetAllowedGroupsForUser

```csharp
/// <summary>
/// 取得使用者可操作的群組清單
/// 邏輯：
/// - 001群組成員：可操作所有群組（包括001）
/// - 非001群組成員：可操作所有群組，但不包括001
/// </summary>
private List<string> GetAllowedGroupsForUser(string sysId, string userId)
{
    var allowedGroups = new List<string>();

    try
    {
        // ✅ Step 1: 檢查是否為 001 群組成員
        string checkAdminSql = @"
            SELECT COUNT(1) 
            FROM AP_USER 
            WHERE SYS_ID = @SYS_ID 
              AND U_ID = @U_ID 
              AND RTRIM(APG_NO) = '001'";

        var adminParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = userId }
        };

        var adminResult = SVS_DBmanager.QueryBySQL(checkAdminSql, adminParams);
        bool isAdmin = Convert.ToInt32(adminResult.Rows[0][0]) > 0;

        if (isAdmin)
        {
            // ✅ 001 群組成員：回傳所有群組（包括 001）
            string allGroupsSql = @"
                SELECT APG_NO 
                FROM AP_GROUP 
                WHERE SYS_ID = @SYS_ID
                ORDER BY APG_NO";

            var allGroupsParams = new List<SqlParameter>
            {
                new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId }
            };

            var allGroupsResult = SVS_DBmanager.QueryBySQL(allGroupsSql, allGroupsParams);

            foreach (DataRow row in allGroupsResult.Rows)
            {
                allowedGroups.Add(row["APG_NO"].ToString().Trim());
            }

            System.Diagnostics.Debug.WriteLine($"[GetAllowedGroups] User {userId} 是 001 管理員，可存取所有群組: {string.Join(", ", allowedGroups)}");
        }
        else
        {
            // ✅ 非 001 群組成員：回傳所有群組，但排除 001
            string nonAdminGroupsSql = @"
                SELECT APG_NO 
                FROM AP_GROUP 
                WHERE SYS_ID = @SYS_ID
                  AND RTRIM(APG_NO) <> '001'
                ORDER BY APG_NO";

            var nonAdminParams = new List<SqlParameter>
            {
                new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId }
            };

            var nonAdminResult = SVS_DBmanager.QueryBySQL(nonAdminGroupsSql, nonAdminParams);

            foreach (DataRow row in nonAdminResult.Rows)
            {
                allowedGroups.Add(row["APG_NO"].ToString().Trim());
            }

            System.Diagnostics.Debug.WriteLine($"[GetAllowedGroups] User {userId} 為非 001 使用者，可存取的群組（排除001）: {string.Join(", ", allowedGroups)}");
        }
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"[GetAllowedGroups] 錯誤: {ex.Message}");
    }

    return allowedGroups;
}
```

## 修正後的 HasGroupPermission

Service 層的驗證也要調整：

```csharp
/// <summary>
/// 檢查使用者是否有權限操作指定群組
/// 邏輯：
/// - 001成員：可操作所有群組
/// - 非001成員：可操作所有群組，但不能操作001
/// </summary>
private bool HasGroupPermission(string sysId, string an, string userId)
{
    try
    {
        string permissionCheckSql = @"
            SELECT 
                CASE 
                    -- 情況1: 如果我是 001 群組成員 → 有完整權限
                    WHEN EXISTS (
                        SELECT 1 FROM AP_USER 
                        WHERE SYS_ID = @SYS_ID 
                          AND RTRIM(APG_NO) = '001'
                          AND U_ID = @U_ID
                    ) THEN 1
                    
                    -- 情況2: 如果目標是 001 但我不是 001 → 無權限
                    WHEN RTRIM(@AN) = '001' THEN 0
                    
                    -- 情況3: 如果我不是 001，但目標也不是 001 → 有權限
                    WHEN EXISTS (
                        SELECT 1 FROM AP_USER
                        WHERE SYS_ID = @SYS_ID
                          AND U_ID = @U_ID
                    ) THEN 1
                    
                    ELSE 0
                END AS HasPermission";

        var parameters = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = userId }
        };

        var result = SVS_DBmanager.QueryBySQL(permissionCheckSql, parameters);

        return result.Rows.Count > 0 && Convert.ToInt32(result.Rows[0]["HasPermission"]) == 1;
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"[HasGroupPermission] Error: {ex.Message}");
        return false;
    }
}
```

## 新的權限矩陣

|使用者群組|嘗試操作的群組|結果|說明               |
|-----|-------|--|-----------------|
|001  |001    |✅ |001可以操作所有群組（包括自己）|
|001  |002    |✅ |001可以操作所有群組      |
|001  |003    |✅ |001可以操作所有群組      |
|002  |001    |❌ |非001不能操作001      |
|002  |002    |✅ |非001可以操作其他所有群組   |
|002  |003    |✅ |002可以管理003的使用者   |
|003  |001    |❌ |非001不能操作001      |
|003  |002    |✅ |003可以管理002的使用者   |
|003  |003    |✅ |003可以管理自己        |

## 測試場景

### 場景 1：002 操作 003（✅ 通過）

```
使用者: 3B750
所屬群組: 002
嘗試操作: 003 ← 匯入使用者到003群組

Controller:
  isAdmin = false
  SQL: SELECT APG_NO FROM AP_GROUP WHERE SYS_ID=... AND APG_NO <> '001'
  allowedGroups = ["002", "003", "004", "005", ...]  ← 所有群組除了001
  apgNo = "003"
  allowedGroups.Contains("003") = true ✅
  → 通過

Service:
  HasGroupPermission("003", "3B750")
    CASE:
      - 我是001？ NO
      - 目標是001？ NO
      - 我存在於系統中？ YES (在002群組)
      → RETURN 1 ✅
  → 通過

Database:
  INSERT ... WHERE EXISTS (
    SELECT 1 FROM AP_USER 
    WHERE U_ID = '3B750'  ← 驗證操作者存在
  )
  → 成功 ✅
```

-----

### 場景 2：002 嘗試操作 001（❌ 被擋）

```
使用者: 3B750
所屬群組: 002
嘗試操作: 001 ← 惡意篡改前端，想匯入到001群組

Controller:
  isAdmin = false
  SQL: SELECT APG_NO FROM AP_GROUP WHERE SYS_ID=... AND APG_NO <> '001'
  allowedGroups = ["002", "003", "004", "005", ...]  ← 不包含001
  apgNo = "001"
  allowedGroups.Contains("001") = false ❌
  → 立即拒絕，回傳 "無權限操作此群組"
```

-----

### 場景 3：001 操作 001（✅ 通過）

```
使用者: ADMIN001
所屬群組: 001
嘗試操作: 001

Controller:
  isAdmin = true
  SQL: SELECT APG_NO FROM AP_GROUP WHERE SYS_ID=...
  allowedGroups = ["001", "002", "003", "004", ...]  ← 包含所有群組
  apgNo = "001"
  allowedGroups.Contains("001") = true ✅
  → 通過

Service:
  HasGroupPermission("001", "ADMIN001")
    CASE:
      - 我是001？ YES
      → RETURN 1 ✅
  → 通過
```

-----

### 場景 4：003 操作 002（✅ 通過）

```
使用者: USER003
所屬群組: 003
嘗試操作: 002 ← 003可以管理002的使用者

Controller:
  isAdmin = false
  allowedGroups = ["002", "003", "004", "005", ...]
  apgNo = "002"
  allowedGroups.Contains("002") = true ✅
  → 通過

Service:
  HasGroupPermission("002", "USER003")
    CASE:
      - 我是001？ NO
      - 目標是001？ NO
      - 我存在於系統中？ YES (在003群組)
      → RETURN 1 ✅
  → 通過
```

## 關鍵修改點

### 修改 1：Controller 層

```csharp
// ❌ 舊邏輯：只能操作自己的群組
string userGroupsSql = @"
    SELECT APG_NO FROM AP_USER 
    WHERE SYS_ID = @SYS_ID AND U_ID = @U_ID";

// ✅ 新邏輯：可以操作所有群組（除了001）
string nonAdminGroupsSql = @"
    SELECT APG_NO FROM AP_GROUP 
    WHERE SYS_ID = @SYS_ID AND RTRIM(APG_NO) <> '001'";
```

### 修改 2：Service 層

```csharp
// ❌ 舊邏輯：需要在目標群組中
WHEN EXISTS (
    SELECT 1 FROM AP_USER
    WHERE SYS_ID = @SYS_ID
      AND APG_NO = @AN  ← 必須在目標群組
      AND U_ID = @U_ID
) THEN 1

// ✅ 新邏輯：只要存在於系統中（且目標不是001）
WHEN EXISTS (
    SELECT 1 FROM AP_USER
    WHERE SYS_ID = @SYS_ID
      AND U_ID = @U_ID  ← 只要存在就好
) THEN 1
```

## SQL 層的 EXISTS 條件也要調整

在所有的 SQL 查詢中，把權限檢查改成：

```sql
-- ❌ 舊寫法：需要在目標群組或001
WHERE EXISTS (
    SELECT 1 FROM AP_USER
    WHERE SYS_ID = @SYS_ID
      AND (APG_NO = @AN OR APG_NO = '001')
      AND U_ID = @CREATOR
)

-- ✅ 新寫法：只要存在就可以（Fortify看到UserID驗證即可）
WHERE EXISTS (
    SELECT 1 FROM AP_USER
    WHERE SYS_ID = @SYS_ID
      AND U_ID = @CREATOR
)
```

但要配合前面的 `HasGroupPermission` 擋住 001 的操作。

## 完整的防護邏輯

```
請求：002 想匯入使用者到 003

第一層防護 (Controller):
  ├─ 002 是 001？ NO
  ├─ 取得允許的群組：[002, 003, 004, ...] (排除 001)
  ├─ 003 在清單中？ YES ✅
  └─ 放行

第二層防護 (Service):
  ├─ HasGroupPermission(003, USER_002)
  │   ├─ USER_002 是 001？ NO
  │   ├─ 目標是 001？ NO
  │   ├─ USER_002 存在系統中？ YES ✅
  │   └─ 回傳 1 (有權限)
  └─ 放行

第三層防護 (Database):
  ├─ INSERT ... WHERE EXISTS (SELECT 1 FROM AP_USER WHERE U_ID = USER_002)
  ├─ USER_002 存在？ YES ✅
  └─ 執行 INSERT
```

現在邏輯是不是對了？​​​​​​​​​​​​​​​​