我了解問題了！當使用 TOKEN 進入時，不應該執行 `GetTicket()` 並取得目錄樹，因為 TOKEN 使用者是針對特定系統的，不需要看到完整的目錄選單。

讓我修改 `HI_APACCESSBaseController.cs`：

```csharp
using HI_APACCESS.Service;
using HI_APACCESS.ViewModels;
using Newtonsoft.Json;
using Serilog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Web.Mvc;
using System.Web.Security;
using System.IO;
using System.Text.RegularExpressions;
using HI_APACCESS.Factory.F_AP;
using HI_APACCESS.AttributeFilter;

namespace HI_APACCESS.Controllers
{
    [AP_LOG]
    [AP_LOG_Exception]
    public abstract class HI_APACCESSBaseController : Controller
    {
        private FormsAuthenticationTicket ticket;
        private string str_AD_Form;
        private string str_UserData_Form;
        private string AD;
        public string Emp_NO_原始;
        public string Emp_NO;
        private VM_Employee.VM_員工部門職稱 Emp_Data;
        public string APG_NO;
        public List<VM_Employee.WebTree_Node> WebTrees;

        // 新增：判斷是否為 TOKEN 登入
        private bool IsTokenLogin
        {
            get
            {
                return !string.IsNullOrEmpty(Session["CurrentSystemId"] as string) &&
                       !string.IsNullOrEmpty(Session["CurrentEmpNo"] as string);
            }
        }

        public HI_APACCESSBaseController()
        {
            this.Emp_NO_原始 = SVS_員工基本資料.Get_員工編號(SVS_員工基本資料.Get_員工AD());
            this.Emp_NO = SVS_員工基本資料.Get_員工編號(this.AD).ToUpper().Trim();
        }

        private void GetTicket()
        {
            // 如果是 TOKEN 登入，不執行 Ticket 邏輯
            if (IsTokenLogin)
            {
                // TOKEN 登入：從 Session 取得員工編號
                this.Emp_NO = Session["CurrentEmpNo"] as string;
                this.AD = this.Emp_NO; // TOKEN 使用者使用員工編號作為 AD
                this.APG_NO = string.Empty; // TOKEN 使用者不需要 APG_NO
                this.WebTrees = new List<VM_Employee.WebTree_Node>(); // TOKEN 使用者不顯示目錄樹
                this.Emp_Data = null; // TOKEN 使用者不需要完整員工資料
                return;
            }

            // 一般登入：執行原本的 Ticket 邏輯
            this.ticket = null;
            var authCookie = Request.Cookies[FormsAuthentication.FormsCookieName];
            if (authCookie != null && !string.IsNullOrWhiteSpace(authCookie.Value))
            {
                var decryptedTicket = FormsAuthentication.Decrypt(authCookie.Value);
                if (decryptedTicket.Expiration >= DateTime.Now)
                {
                    this.ticket = decryptedTicket;
                    this.str_AD_Form = this.ticket?.Name;
                    this.str_UserData_Form = this.ticket?.UserData;
                    this.AD = !string.IsNullOrEmpty(str_AD_Form) ? str_AD_Form : SVS_員工基本資料.Get_員工AD();
                    this.Emp_NO = SVS_員工基本資料.Get_員工編號(this.AD).ToUpper().Trim();
                    this.Emp_Data = !string.IsNullOrEmpty(this.str_UserData_Form) ? JsonConvert.DeserializeObject<VM_Employee.VM_員工部門職稱>(this.str_UserData_Form) : SVS_員工基本資料.Get_員工基本資料(this.Emp_NO_原始);
                    this.APG_NO = this.Emp_Data?.APG_NO ?? string.Empty;
                    
                    // 一般登入才取得目錄樹
                    this.WebTrees = string.IsNullOrEmpty(this.APG_NO) ? new List<VM_Employee.WebTree_Node>() : SVS_員工基本資料.Get_Tree(this.APG_NO);
                }
            }
        }

        protected override void HandleUnknownAction(string actionName)
        {
            this.Redirect("/?wrongView=" + actionName).ExecuteResult(this.ControllerContext);
        }

        protected override void OnException(ExceptionContext filterContext)
        {
            base.OnException(filterContext);

            var exception = filterContext.Exception;
            var user = filterContext.RequestContext.HttpContext.User;

            if ((exception is CryptographicException)
                || (exception is HttpAntiForgeryException && (user == null || !user.Identity.IsAuthenticated)))
            {
                HandleAuthenticationException(filterContext);
                return;
            }

            if (exception is HttpAntiForgeryException)
            {
                var action = filterContext.RequestContext.RouteData.Values["action"] as string;
                var controller = filterContext.RequestContext.RouteData.Values["controller"] as string;
                if (action == "Login" && controller == "Account" && user != null && user.Identity.IsAuthenticated)
                {
                    HandleAuthenticationException(filterContext);
                    return;
                }
            }

            ILogger log = SVS_Serilog._log;
            log.Error<string>(exception, exception.Message, exception.StackTrace);
        }

        private void HandleAuthenticationException(ExceptionContext filterContext)
        {
            filterContext.ExceptionHandled = true;
            Session.Abandon();
            FormsAuthentication.SignOut();
            filterContext.Result = new RedirectResult(Url.Action("Login", "Account"));
        }

        private static string[] List_排除清單_ctrl => Array.ConvertAll(new string[] { "Account", "Home", "SYSTEM_SET", "AP", "SYS" }, x => x.ToUpper());
        private static string[] List_排除清單_action => Array.ConvertAll(new string[]
        {
          "Login", "Logout", "RefreshSession", "Main" //其他
          ,"PageManagement","GroupManagement","Index","TokenEntry","TokenEntry_FUNC","Entry","Entry_FUNC"
          ,"SYS_APPLY","SYS_FUNC_SET","SYS_PERMISSION_SET"

        }, x => x.ToUpper());

        //頁面權限統一控管，沒有權限就導去公佈欄頁面
        protected override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            base.OnActionExecuting(filterContext);
            GetTicket();

            if (filterContext.ActionDescriptor is ReflectedActionDescriptor actionDescriptor)
            {
                string ReturnType = actionDescriptor.MethodInfo.ReturnType.Name;
                string ctrlName = filterContext.ActionDescriptor.ControllerDescriptor.ControllerName.ToUpper();
                string actionName = filterContext.ActionDescriptor.ActionName.ToUpper();

                // TOKEN 登入使用者：跳過所有權限檢查
                if (IsTokenLogin)
                {
                    return;
                }

                // AP、HOME、特定 Action 不做權限檢查
                if (ctrlName == "AP" || ctrlName == "HOME" ||
                    new[] { "PAGEMANAGEMENT", "GROUPMANAGEMENT", "TOKENENTRY", "TOKENENTRY_FUNC", "INDEX" }.Contains(actionName))
                {
                    return;
                }

                // 一般登入使用者：進行權限檢查
                if (ReturnType == "ActionResult"
                    && filterContext.HttpContext.Request.HttpMethod == "GET"
                    && !filterContext.HttpContext.Request.IsAjaxRequest())
                {
                    var _List_排除清單_ctrl = List_排除清單_ctrl.Select(x => x.ToUpper()).ToArray();
                    var _List_排除清單_action = List_排除清單_action.Select(x => x.ToUpper()).ToArray();

                    if (WebTrees != null
                        && !_List_排除清單_ctrl.Contains(ctrlName)
                        && !WebTrees.Any(x => string.IsNullOrEmpty(x.PARENT_ID) && x.FUNC_ID == ctrlName))
                    {
                        filterContext.Result = new RedirectResult(Url.Action("Main", "Home"));
                        return;
                    }
                }
            }
        }

        protected string CurrentSystemId
        {
            get
            {
                return Session["CurrentSystemId"] as string;
            }
        }

        protected F_AP GetAPService()
        {
            string currentSystemId = Session["CurrentSystemId"] as string;
            if (string.IsNullOrEmpty(currentSystemId))
            {
                throw new InvalidOperationException("系統ID遺失，請重新登入");
            }
            return new F_AP(currentSystemId);
        }
    }
}
```

## 關鍵修改說明

### 1. **新增 `IsTokenLogin` 屬性**

```csharp
private bool IsTokenLogin
{
    get
    {
        return !string.IsNullOrEmpty(Session["CurrentSystemId"] as string) &&
               !string.IsNullOrEmpty(Session["CurrentEmpNo"] as string);
    }
}
```

用來判斷當前使用者是否透過 TOKEN 登入。

### 2. **修改 `GetTicket()` 方法**

```csharp
private void GetTicket()
{
    // 如果是 TOKEN 登入，不執行 Ticket 邏輯
    if (IsTokenLogin)
    {
        this.Emp_NO = Session["CurrentEmpNo"] as string;
        this.AD = this.Emp_NO;
        this.APG_NO = string.Empty;
        this.WebTrees = new List<VM_Employee.WebTree_Node>(); // 👈 空的目錄樹
        this.Emp_Data = null;
        return; // 直接返回，不執行下面的 Ticket 邏輯
    }
    
    // 一般登入才執行原本的邏輯...
}
```

### 3. **修改 `OnActionExecuting()` 權限檢查**

```csharp
protected override void OnActionExecuting(ActionExecutingContext filterContext)
{
    base.OnActionExecuting(filterContext);
    GetTicket();
    
    // TOKEN 登入使用者：跳過所有權限檢查
    if (IsTokenLogin)
    {
        return; // 👈 TOKEN 使用者直接通過，不檢查目錄樹
    }
    
    // 一般登入使用者：進行原本的權限檢查...
}
```

## 效果

### **TOKEN 登入時：**

- ✅ `WebTrees` = 空清單，不會顯示目錄樹
- ✅ 跳過所有權限檢查
- ✅ 只能訪問 `GroupManagement` 和 `PageManagement`
- ✅ `Emp_NO` 從 Session 取得

### **一般登入時：**

- ✅ `WebTrees` = 完整目錄樹，正常顯示選單
- ✅ 執行權限檢查
- ✅ 可以訪問所有有權限的頁面（包括新增的三個 SYS 功能）
- ✅ `Emp_NO` 從 Ticket 取得

## 補充：如果你的 Layout 或 _Menu 有使用到 WebTrees

確保你的 View 中有判斷，例如：

```html
<!-- 在 _Layout.cshtml 或 _Menu.cshtml 中 -->
@if (Model.WebTrees != null && Model.WebTrees.Any())
{
    <!-- 顯示目錄樹 -->
    @foreach (var node in Model.WebTrees)
    {
        <!-- 渲染選單 -->
    }
}
else
{
    <!-- TOKEN 使用者不顯示目錄樹 -->
}
```

這樣修改後，TOKEN 登入的使用者就不會看到目錄樹了！有任何問題隨時告訴我。​​​​​​​​​​​​​​​​