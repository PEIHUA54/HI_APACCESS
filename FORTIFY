## Fortify 如何判斷是否有驗證？

**Fortify 的分析方式：**

Fortify 做的是**靜態程式碼分析**（Static Analysis），它會：

1. **追蹤資料流路徑**：
   
   ```
   apgNo (來自 HTTP POST) → 參數傳遞 → SQL 查詢使用
   ```
1. **檢查中間是否有「驗證模式」**：

- 是否有 `if` 判斷這個變數
- 是否有呼叫驗證函數
- 是否有資料庫查詢檢查這個值的合法性
- **關鍵：是否在使用前有任何「檢查動作」**

1. **如果沒有驗證，就會標記為問題**

**例如：**

```csharp
// ❌ Fortify 會報錯
public void Process(string apgNo) {
    string sql = "SELECT * FROM AP_USER WHERE APG_NO=@APG_NO";
    cmd.Parameters.AddWithValue("@APG_NO", apgNo); // 直接使用，沒驗證
}

// ✅ Fortify 可能通過
public void Process(string apgNo) {
    // 有驗證動作
    if (!IsValidGroup(apgNo)) {
        throw new Exception("Invalid group");
    }
    
    string sql = "SELECT * FROM AP_USER WHERE APG_NO=@APG_NO";
    cmd.Parameters.AddWithValue("@APG_NO", apgNo); // 驗證後使用
}
```

**但是！Fortify 不會理解業務邏輯**：

- 它不知道你的群組 001 是最高權限
- 它只看「有沒有檢查」，不管「檢查邏輯對不對」

-----

## 我給的驗證邏輯解釋

讓我重新看一下我之前給的程式碼：

```csharp
string authCheckSql = @"
    SELECT COUNT(1) 
    FROM AP_GROUP 
    WHERE SYS_ID = @SYS_ID 
      AND APG_NO = @APG_NO 
      AND (CREATOR = @CREATOR OR EXISTS (
          SELECT 1 FROM AP_USER 
          WHERE SYS_ID = @SYS_ID 
            AND APG_NO = @APG_NO 
            AND U_ID = @CREATOR
      ))";
```

**這段邏輯的意思是：**

```
檢查當前使用者（creator）是否有權限操作這個群組（apgNo）

條件一：CREATOR = @CREATOR
→ 如果當前使用者是這個群組的建立者

條件二：OR EXISTS (SELECT 1 FROM AP_USER WHERE APG_NO = @APG_NO AND U_ID = @CREATOR)
→ 或者當前使用者本身就在這個群組裡

只要符合其中一個條件，就允許操作
```

**但這個邏輯有問題！**

- 它沒有考慮「群組 001 是最高權限」
- 它只允許「建立者」或「群組成員」操作，太嚴格了

-----

## 針對你的業務邏輯：正確的驗證方式

**你的需求：**

- 群組 001 的成員可以操作所有群組
- 其他群組只能操作自己的群組

### 修正後的驗證邏輯：

```csharp
public ImportResult ImportUsersFromExcel(string filePath, string sysId, string apgNo, string creator)
{
    ImportResult result = new ImportResult()
    {
        ErrorMessages = new List<ImportError>()
    };

    try
    {
        using (SqlConnection con = new SqlConnection(ConfigurationManager.ConnectionStrings["ConnDB_TFS_HI-AUTOS"].ConnectionString))
        {
            con.Open();

            // **驗證權限：檢查使用者是否有權限操作目標群組**
            if (!HasGroupPermission(con, sysId, apgNo, creator))
            {
                result.IsSuccess = false;
                result.ErrorMessage = "無權限操作此群組";
                return result;
            }

            // 讀 Excel
            var rows = new List<(int RowNumber, string EmpNo)>();
            // ... 原本的邏輯
        }
    }
    catch (Exception ex)
    {
        result.IsSuccess = false;
        result.ErrorMessage = "處理 Excel 匯入時發生錯誤：" + ex.Message;
    }

    return result;
}

// **權限檢查方法**
private bool HasGroupPermission(SqlConnection con, string sysId, string targetApgNo, string userId)
{
    // 方案一：檢查使用者是否在群組 001
    string checkAdminSql = @"
        SELECT COUNT(1) 
        FROM AP_USER 
        WHERE SYS_ID = @SYS_ID 
          AND APG_NO = '001' 
          AND U_ID = @U_ID";
    
    using (var cmd = new SqlCommand(checkAdminSql, con))
    {
        cmd.Parameters.AddWithValue("@SYS_ID", sysId);
        cmd.Parameters.AddWithValue("@U_ID", userId);
        
        int isAdmin = (int)cmd.ExecuteScalar();
        
        // 如果是 001 群組成員，有權限操作所有群組
        if (isAdmin > 0)
            return true;
    }
    
    // 方案二：檢查使用者是否在目標群組
    string checkMemberSql = @"
        SELECT COUNT(1) 
        FROM AP_USER 
        WHERE SYS_ID = @SYS_ID 
          AND APG_NO = @APG_NO 
          AND U_ID = @U_ID";
    
    using (var cmd = new SqlCommand(checkMemberSql, con))
    {
        cmd.Parameters.AddWithValue("@SYS_ID", sysId);
        cmd.Parameters.AddWithValue("@APG_NO", targetApgNo);
        cmd.Parameters.AddWithValue("@U_ID", userId);
        
        int isMember = (int)cmd.ExecuteScalar();
        
        // 如果是目標群組成員，有權限操作該群組
        return isMember > 0;
    }
}
```

**邏輯說明：**

1. **先檢查是否為 001 群組成員**
   
   ```sql
   SELECT COUNT(1) FROM AP_USER 
   WHERE SYS_ID = 'XXX' AND APG_NO = '001' AND U_ID = 'creator'
   ```

- 如果 COUNT > 0，表示是最高權限，直接 return true

1. **如果不是 001，檢查是否為目標群組成員**
   
   ```sql
   SELECT COUNT(1) FROM AP_USER 
   WHERE SYS_ID = 'XXX' AND APG_NO = 'targetApgNo' AND U_ID = 'creator'
   ```

- 如果 COUNT > 0，表示是該群組成員，可以操作自己的群組

-----

## 進階：如果權限更複雜

如果你的權限結構更複雜（例如有管理員角色、權限等級表），可以這樣設計：

```csharp
private bool HasGroupPermission(SqlConnection con, string sysId, string targetApgNo, string userId)
{
    string permissionCheckSql = @"
        SELECT 
            CASE 
                -- 情況1：使用者在 001 群組（最高權限）
                WHEN EXISTS (
                    SELECT 1 FROM AP_USER 
                    WHERE SYS_ID = @SYS_ID AND APG_NO = '001' AND U_ID = @U_ID
                ) THEN 1
                
                -- 情況2：使用者是目標群組的建立者
                WHEN EXISTS (
                    SELECT 1 FROM AP_GROUP 
                    WHERE SYS_ID = @SYS_ID AND APG_NO = @APG_NO AND CREATOR = @U_ID
                ) THEN 1
                
                -- 情況3：使用者是目標群組的成員
                WHEN EXISTS (
                    SELECT 1 FROM AP_USER 
                    WHERE SYS_ID = @SYS_ID AND APG_NO = @APG_NO AND U_ID = @U_ID
                ) THEN 1
                
                -- 其他情況：無權限
                ELSE 0
            END AS HasPermission";
    
    using (var cmd = new SqlCommand(permissionCheckSql, con))
    {
        cmd.Parameters.AddWithValue("@SYS_ID", sysId);
        cmd.Parameters.AddWithValue("@APG_NO", targetApgNo);
        cmd.Parameters.AddWithValue("@U_ID", userId);
        
        int hasPermission = (int)cmd.ExecuteScalar();
        return hasPermission == 1;
    }
}
```

-----

## 總結

1. **Fortify 檢查方式**：

- 看資料流有沒有被驗證過
- 不理解業務邏輯
- 只要有「檢查動作」就可能通過

1. **正確的驗證邏輯**：
   
   ```
   if (使用者在 001 群組) → 允許操作所有群組
   else if (使用者在目標群組) → 只允許操作該群組
   else → 拒絕
   ```
1. **關鍵點**：

- 在使用 `apgNo` 之前必須先驗證
- 驗證邏輯要符合業務需求
- Fortify 只看「有沒有驗證」，不管「驗證對不對」

**你需要根據實際的權限設計來調整驗證邏輯！**