懂了!你說得對!

因為用 `Type=1` 會查**全部員工**(在職+離職),如果資料庫裡有很多離職員工,可能會一直卡在第一個離職的人。

應該用 `Type=3` 指定要查詢的員工編號,這樣只會查詢特定的員工!

讓我修正 `ValidateEmployee` 方法:

-----

## 修正 F_AP 的 ValidateEmployee 方法

```csharp
/// <summary>
/// 呼叫 DLL 檢查員工是否存在及是否離職
/// </summary>
/// <param name="empNo">員工編號</param>
/// <param name="empName">員工姓名(輸出)</param>
/// <param name="errorMessage">錯誤訊息(輸出)</param>
/// <returns>true:可以使用, false:不可使用</returns>
private bool ValidateEmployee(string empNo, out string empName, out string errorMessage)
{
    empName = string.Empty;
    errorMessage = string.Empty;

    try
    {
        // ⭐ 使用 Type=3 指定查詢特定員工
        var request = new
        {
            Type = "3",  // 指定名單
            EmpNoList = new List<string> { empNo },  // 只查詢這個員工
            Environment = EnvHelper.EnvironmentForDll()
        };

        string requestJson = JsonConvert.SerializeObject(request);
        string responseJson = new HI_APACCESS_DLL.APACCESS().GetEmpMast(requestJson);
        
        var response = JsonConvert.DeserializeObject<GetEmpMastModel.GetEmpMastResponse>(responseJson);

        // 檢查是否有查到資料
        if (response.Result == null || response.Result.Count == 0)
        {
            errorMessage = "查無此員工";
            return false;
        }

        var empData = response.Result[0];
        empName = empData.EmpName;

        // ⭐ 檢查是否離職 (EndDate 有值 = 離職)
        if (!string.IsNullOrEmpty(empData.EndDate?.Trim()))
        {
            errorMessage = $"此員工已離職 (離職日期: {empData.EndDate})";
            return false;
        }

        // ⭐ 驗證姓名長度（nvarchar(20)）
        if (empName.Length > 20)
        {
            errorMessage = "員工姓名長度超過20個字元";
            return false;
        }

        return true;
    }
    catch (Exception ex)
    {
        errorMessage = "查詢員工資料時發生錯誤：" + ex.Message;
        return false;
    }
}
```

-----

## 完整的三個方法 (F_AP)

```csharp
/// <summary>
/// 呼叫 DLL 檢查員工是否存在及是否離職
/// </summary>
/// <param name="empNo">員工編號</param>
/// <param name="empName">員工姓名(輸出)</param>
/// <param name="errorMessage">錯誤訊息(輸出)</param>
/// <returns>true:可以使用, false:不可使用</returns>
private bool ValidateEmployee(string empNo, out string empName, out string errorMessage)
{
    empName = string.Empty;
    errorMessage = string.Empty;

    try
    {
        // ⭐ 使用 Type=3 指定查詢特定員工
        var request = new
        {
            Type = "3",
            EmpNoList = new List<string> { empNo },
            Environment = EnvHelper.EnvironmentForDll()
        };

        string requestJson = JsonConvert.SerializeObject(request);
        string responseJson = new HI_APACCESS_DLL.APACCESS().GetEmpMast(requestJson);
        
        var response = JsonConvert.DeserializeObject<GetEmpMastModel.GetEmpMastResponse>(responseJson);

        if (response.Result == null || response.Result.Count == 0)
        {
            errorMessage = "查無此員工";
            return false;
        }

        var empData = response.Result[0];
        empName = empData.EmpName;

        if (!string.IsNullOrEmpty(empData.EndDate?.Trim()))
        {
            errorMessage = $"此員工已離職 (離職日期: {empData.EndDate})";
            return false;
        }

        if (empName.Length > 20)
        {
            errorMessage = "員工姓名長度超過20個字元";
            return false;
        }

        return true;
    }
    catch (Exception ex)
    {
        errorMessage = "查詢員工資料時發生錯誤：" + ex.Message;
        return false;
    }
}

/// <summary>
/// 單筆新增時驗證員工 (對外公開方法)
/// </summary>
/// <param name="empNo">員工編號</param>
/// <param name="empName">員工姓名(輸出)</param>
/// <returns>錯誤訊息,null表示驗證通過</returns>
public string ValidateEmployeeForInsert(string empNo, out string empName)
{
    if (!ValidateEmployee(empNo, out empName, out string errorMessage))
    {
        return errorMessage;
    }
    return null;
}

/// <summary>
/// 處理單筆員工資料 (批次匯入用)
/// </summary>
private bool ProcessUserRow((int RowNumber, string EmpNo) row, string sysId, string an, string creator, ImportResult result)
{
    try
    {
        // 1. ⭐ 使用 DLL 檢查員工 (Type=3 指定查詢)
        if (!ValidateEmployee(row.EmpNo, out string empName, out string errorMessage))
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = errorMessage
            });
            return false;
        }

        // 2. 檢查是否已存在於同一個群組
        string checkUserSql = SVS_DBmanager.GetQuery(SVS_DBmanager.QueryKey.ProcessUserRow_chkuser);
        var checkUserParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = row.EmpNo },
            new SqlParameter("@CREATOR", SqlDbType.VarChar, 10) { Value = creator }
        };
        var userResult = SVS_DBmanager.QueryBySQL(checkUserSql, checkUserParams);

        if (Convert.ToInt32(userResult.Rows[0][0]) > 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "此群組已存在該員工"
            });
            return false;
        }

        // 3. 檢查是否已存在於該系統的其他群組
        string checkSystemSql = SVS_DBmanager.GetQuery(SVS_DBmanager.QueryKey.ProcessUserRow_chksys);
        var checkSystemParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = row.EmpNo },
            new SqlParameter("@CREATOR", SqlDbType.VarChar, 10) { Value = creator }
        };
        var systemResult = SVS_DBmanager.QueryBySQL(checkSystemSql, checkSystemParams);

        if (Convert.ToInt32(systemResult.Rows[0][0]) > 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "此系統其他群組已存在該員工"
            });
            return false;
        }

        // 4. 寫入 AP_USER
        string insertSql = @"
    INSERT INTO AP_USER(SYS_ID, APG_NO, U_ID, U_NAME, CREATOR, CREATE_TIME)
    SELECT @SYS_ID, @AN, @U_ID, @U_NAME, @CREATOR, GETDATE()
    WHERE EXISTS (
        SELECT 1 FROM AP_USER
        WHERE SYS_ID = @SYS_ID
          AND (APG_NO = @AN OR APG_NO = '001')
          AND U_ID = @CREATOR
    )";
        var insertParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = row.EmpNo },
            new SqlParameter("@U_NAME", SqlDbType.NVarChar, 20) { Value = empName },
            new SqlParameter("@CREATOR", SqlDbType.VarChar, 10) { Value = creator }
        };

        SVS_DBmanager.ExecuteSQL(insertSql, insertParams);

        return true;
    }
    catch (Exception exRow)
    {
        result.ErrorMessages.Add(new ImportError
        {
            RowNumber = row.RowNumber,
            EmpNo = row.EmpNo,
            Message = "寫入錯誤：" + exRow.Message
        });
        return false;
    }
}
```

-----

## Controller 的 AddUser 保持不變

```csharp
// 新增使用者
[HttpPost]
public JsonResult AddUser([Bind] UserModel model)
{
    try
    {
        model.SYS_ID = CurrentSystemId;

        if (ModelState.IsValid)
        {
            var service = GetAPService();
            
            // ⭐ 使用 F_AP 的方法檢查員工 (內部用 Type=3)
            string validationError = service.ValidateEmployeeForInsert(model.U_ID, out string empName);
            if (validationError != null)
            {
                return Json(new { success = false, message = validationError });
            }

            if (string.IsNullOrWhiteSpace(model.U_NAME))
            {
                model.U_NAME = empName;
            }

            var result = service.InsertUser(model, Emp_NO);
            if (result == null || !result.Contains("fail"))
            {
                return Json(new { success = true, message = "使用者新增成功" });
            }
            else
            {
                return Json(new { success = false, message = "使用者新增失敗：" + result });
            }
        }
        return Json(new { success = false, message = "資料驗證失敗" });
    }
    catch (Exception ex)
    {
        return Json(new { success = false, message = "新增使用者發生錯誤：" + ex.Message });
    }
}
```

-----

## 重點說明

- ✅ 改用 **Type=3** + 指定 `EmpNoList`
- ✅ 只查詢**特定的員工編號**
- ✅ 不會被其他離職員工影響
- ✅ 單筆新增、批次匯入都用同一個 `ValidateEmployee` 方法

這樣就對了!​​​​​​​​​​​​​​​​