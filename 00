對!你說得對!可以直接用你的 `HI_APACCESS_DLL` 的 `GetEmpMast` 方法!

讓我重新整理離職檢查的完整方案:

-----

## 一、不需要修改 SQL QueryKey

因為我們改用 DLL,所以 `ProcessUserRow_chkemp` 這個 QueryKey 可以**刪除**或保持原樣備用。

-----

## 二、F_AP 修改

### 1. 新增輔助方法 - 呼叫 DLL 檢查員工

在 `F_AP` 類別中新增:

```csharp
/// <summary>
/// 呼叫 DLL 檢查員工是否存在及是否離職
/// </summary>
/// <param name="empNo">員工編號</param>
/// <param name="empName">員工姓名(輸出)</param>
/// <param name="errorMessage">錯誤訊息(輸出)</param>
/// <returns>true:可以使用, false:不可使用</returns>
private bool ValidateEmployee(string empNo, out string empName, out string errorMessage)
{
    empName = string.Empty;
    errorMessage = string.Empty;

    try
    {
        // 呼叫 DLL - Type 1 查詢全部(在職+離職)
        var request = new
        {
            Type = "1",
            EmpNoList = new List<string> { empNo },
            Environment = EnvHelper.EnvironmentForDll() // 你的環境判斷方法
        };

        string requestJson = JsonConvert.SerializeObject(request);
        string responseJson = new HI_APACCESS_DLL.APACCESS().GetEmpMast(requestJson);
        
        var response = JsonConvert.DeserializeObject<GetEmpMastModel.GetEmpMastResponse>(responseJson);

        // 檢查是否有查到資料
        if (response.Result == null || response.Result.Count == 0)
        {
            errorMessage = "查無此員工";
            return false;
        }

        var empData = response.Result[0];
        empName = empData.EmpName;

        // ⭐ 檢查是否離職 (END_DT 有值 = 離職)
        if (!string.IsNullOrEmpty(empData.EndDate?.Trim()))
        {
            errorMessage = $"此員工已離職 (離職日期: {empData.EndDate})";
            return false;
        }

        // ⭐ 驗證姓名長度（nvarchar(20)）
        if (empName.Length > 20)
        {
            errorMessage = "員工姓名長度超過20個字元";
            return false;
        }

        return true;
    }
    catch (Exception ex)
    {
        errorMessage = "查詢員工資料時發生錯誤：" + ex.Message;
        return false;
    }
}
```

### 2. 修改 ProcessUserRow 方法 (批次匯入用)

```csharp
/// <summary>
/// 處理單筆員工資料
/// </summary>
private bool ProcessUserRow((int RowNumber, string EmpNo) row, string sysId, string an, string creator, ImportResult result)
{
    try
    {
        // 1. ⭐ 使用 DLL 檢查員工是否存在 + 是否離職
        if (!ValidateEmployee(row.EmpNo, out string empName, out string errorMessage))
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = errorMessage
            });
            return false;
        }

        // 2. 檢查是否已存在於同一個群組
        string checkUserSql = SVS_DBmanager.GetQuery(SVS_DBmanager.QueryKey.ProcessUserRow_chkuser);
        var checkUserParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = row.EmpNo },
            new SqlParameter("@CREATOR", SqlDbType.VarChar, 10) { Value = creator }
        };
        var userResult = SVS_DBmanager.QueryBySQL(checkUserSql, checkUserParams);

        if (Convert.ToInt32(userResult.Rows[0][0]) > 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "此群組已存在該員工"
            });
            return false;
        }

        // 3. 檢查是否已存在於該系統的其他群組
        string checkSystemSql = SVS_DBmanager.GetQuery(SVS_DBmanager.QueryKey.ProcessUserRow_chksys);
        var checkSystemParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = row.EmpNo },
            new SqlParameter("@CREATOR", SqlDbType.VarChar, 10) { Value = creator }
        };
        var systemResult = SVS_DBmanager.QueryBySQL(checkSystemSql, checkSystemParams);

        if (Convert.ToInt32(systemResult.Rows[0][0]) > 0)
        {
            result.ErrorMessages.Add(new ImportError
            {
                RowNumber = row.RowNumber,
                EmpNo = row.EmpNo,
                Message = "此系統其他群組已存在該員工"
            });
            return false;
        }

        // 4. 寫入 AP_USER
        string insertSql = @"
    INSERT INTO AP_USER(SYS_ID, APG_NO, U_ID, U_NAME, CREATOR, CREATE_TIME)
    SELECT @SYS_ID, @AN, @U_ID, @U_NAME, @CREATOR, GETDATE()
    WHERE EXISTS (
        SELECT 1 FROM AP_USER
        WHERE SYS_ID = @SYS_ID
          AND (APG_NO = @AN OR APG_NO = '001')
          AND U_ID = @CREATOR
    )";
        var insertParams = new List<SqlParameter>
        {
            new SqlParameter("@SYS_ID", SqlDbType.VarChar, 30) { Value = sysId },
            new SqlParameter("@AN", SqlDbType.VarChar, 3) { Value = an },
            new SqlParameter("@U_ID", SqlDbType.VarChar, 10) { Value = row.EmpNo },
            new SqlParameter("@U_NAME", SqlDbType.NVarChar, 20) { Value = empName },
            new SqlParameter("@CREATOR", SqlDbType.VarChar, 10) { Value = creator }
        };

        SVS_DBmanager.ExecuteSQL(insertSql, insertParams);

        return true;
    }
    catch (Exception exRow)
    {
        result.ErrorMessages.Add(new ImportError
        {
            RowNumber = row.RowNumber,
            EmpNo = row.EmpNo,
            Message = "寫入錯誤：" + exRow.Message
        });
        return false;
    }
}
```

### 3. 新增 ValidateEmployeeForInsert 方法 (單筆新增用)

```csharp
/// <summary>
/// 單筆新增時驗證員工 (對外公開方法)
/// </summary>
/// <param name="empNo">員工編號</param>
/// <param name="empName">員工姓名(輸出)</param>
/// <returns>錯誤訊息,null表示驗證通過</returns>
public string ValidateEmployeeForInsert(string empNo, out string empName)
{
    if (!ValidateEmployee(empNo, out empName, out string errorMessage))
    {
        return errorMessage;
    }
    return null; // 驗證通過
}
```

-----

## 三、Controller 修改

### 修改 AddUser (單筆新增)

```csharp
// 新增使用者
[HttpPost]
public JsonResult AddUser([Bind] UserModel model)
{
    try
    {
        model.SYS_ID = CurrentSystemId;

        if (ModelState.IsValid)
        {
            var service = GetAPService();
            
            // ⭐ 使用 F_AP 的方法檢查員工是否離職
            string validationError = service.ValidateEmployeeForInsert(model.U_ID, out string empName);
            if (validationError != null)
            {
                return Json(new { success = false, message = validationError });
            }

            // 如果 model.U_NAME 是空的,使用從 DLL 取得的姓名
            if (string.IsNullOrWhiteSpace(model.U_NAME))
            {
                model.U_NAME = empName;
            }

            var result = service.InsertUser(model, Emp_NO);
            if (result == null || !result.Contains("fail"))
            {
                return Json(new { success = true, message = "使用者新增成功" });
            }
            else
            {
                return Json(new { success = false, message = "使用者新增失敗：" + result });
            }
        }
        return Json(new { success = false, message = "資料驗證失敗" });
    }
    catch (Exception ex)
    {
        return Json(new { success = false, message = "新增使用者發生錯誤：" + ex.Message });
    }
}
```

### ImportUsers 方法保持不變

```csharp
// 批次匯入使用者
[HttpPost]
public ActionResult ImportUsers(HttpPostedFileBase file, string apgNo, string sysID)
{
    var service = GetAPService();

    if (file == null || file.ContentLength == 0)
        return Json(new { success = false, message = "請選擇要匯入的Excel檔案" });

    if (string.IsNullOrWhiteSpace(apgNo))
        return Json(new { success = false, message = "請先選擇群組" });

    // 驗證群組權限
    var allowedGroups = service.GetAllowedGroupsForUser(CurrentSystemId, this.Emp_NO);

    if (!allowedGroups.Contains(apgNo))
        throw new UnauthorizedAccessException("未授權的群組操作");

    if (!allowedGroups.Contains(apgNo))
    {
        return Json(new
        {
            success = false,
            message = "無權限操作此群組"
        });
    }

    // 副檔名限制
    var ext = Path.GetExtension(file.FileName).ToLower();
    if (ext != ".xls" && ext != ".xlsx")
        return Json(new { success = false, message = "請上傳Excel檔案（.xls 或 .xlsx）" });

    // 上傳暫存
    var uploadDir = Server.MapPath("~/Upload");
    if (!Directory.Exists(uploadDir)) Directory.CreateDirectory(uploadDir);

    var safeName = $"Import_{apgNo}_{DateTime.Now:yyyyMMddHHmmss}{ext}";
    var uploadPath = PathValidator.GetSafePath(uploadDir, safeName);

    try
    {
        file.SaveAs(uploadPath);
        
        // ⭐ 這裡會自動呼叫 ProcessUserRow,裡面已經包含離職檢查
        var importResult = service.ImportUsersFromExcel(
            uploadPath,
            CurrentSystemId,
            apgNo,
            this.Emp_NO
        );

        if (importResult.SuccessCount > 0 && importResult.ErrorMessages.Count == 0)
        {
            return Json(new
            {
                status = "success",
                message = $"匯入成功：共 {importResult.SuccessCount} 筆"
            });
        }
        else if (importResult.SuccessCount == 0 && importResult.ErrorMessages.Count > 0)
        {
            return Json(new
            {
                status = "fail",
                message = "匯入失敗：請重新上傳",
                errors = importResult.ErrorMessages
            });
        }
        else
        {
            return Json(new
            {
                status = "partial",
                message = $"匯入部分成功：成功 {importResult.SuccessCount} 筆，失敗 {importResult.ErrorMessages.Count} 筆",
                errors = importResult.ErrorMessages
            });
        }
    }
    catch (Exception ex)
    {
        return Json(new { success = false, message = "匯入過程發生錯誤：" + ex.Message });
    }
    finally
    {
        if (System.IO.File.Exists(uploadPath))
        {
            var fc = new F_Common();
            fc.SafeDeleteFile(uploadDir, safeName);
        }
    }
}
```

-----

## 總結修改重點

1. ✅ **新增 `ValidateEmployee` 私有方法** - 統一呼叫 DLL 檢查員工
1. ✅ **新增 `ValidateEmployeeForInsert` 公開方法** - 給 Controller 呼叫
1. ✅ **修改 `ProcessUserRow`** - 批次匯入時使用 DLL 檢查
1. ✅ **修改 `AddUser` Controller** - 單筆新增時呼叫 F_AP 檢查
1. ✅ **不需要修改 SQL** - 直接用 DLL

這樣就完全使用 DLL 來檢查員工資料,包含是否離職的判斷!​​​​​​​​​​​​​​​​